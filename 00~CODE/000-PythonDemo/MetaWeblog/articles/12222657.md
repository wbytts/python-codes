# 概念

一段代码，集中到一起，起一个名字，下一次可以使用这个名字调用这个代码块，就是函数的功能

作用：
- 方便代码的重用
- 分解任务，简化程序逻辑
- 使代码更加模块化

# 函数的分类

- 内建函数
- 第三方函数
- 自定义函数

# 函数定义

## 简单定义

```python
def 函数名():
    函数体代码
```

```python
函数名()  # 函数调用
```

# 参数

## 固定个数的参数

```python
def xxx(参数1, 参数2, ...):
    ......
    # 在函数体，直接以变量的方式使用传过来的参数
```

这种方式，调用的时候，形参与实参一一对应

## 关键字参数

固定个数的参数不止可以按位置一一对应地去调用传参，也可以按参数名进行指定，这种方式不必按照原来的顺序

```python
def xxx(name1, name2, ...):
    ......
```

调用：
```python
xxx(name2=..., name1=...)
```

## 不定长参数

将除了按位置匹配以外的参数，收集到一起

### 收集为元组

```python
def xx(...., *args):
    .....
```

函数调用时，多余的参数，会组成元组赋值给args

### 收集为字典

```python
def xx(...., **kwargs):
    ......
```

可以将多余的关键字参数收集为字典，函数内可以直接当做字典使用

### 参数的拆包和装包

装包：把传递的参数，包装起来
拆包：把包装起来的参数，再次拆分为单独的个体

### 缺省参数

有些参数可以设置默认值，也就是调用的时候如果不传值，则会使用设置的默认值

注意：默认值参数需要写在最后面

# 返回值

函数可以返回任意对象

`return xxx`

注意：
- return后的代码不会被执行
- return只会被执行一次

# 函数描述

在函数体的最前面，添加三引号的注释

可以使用 `help(函数名)` 查看注释的内容 

# 偏函数

当我们写一个参数比较多的函数时，如果有些函数，大部分场景下都是某一个默认值，那么为了简化使用，就可以创建一个新函数，指定我们要使用的函数的某个参数，为某个固定的值，这个新的函数就是 “偏函数”

可以自己手动创建，但是python也为我们提供了专门的工具：
```python
import functools

functools.partial(函数名, 特定参数=偏爱值) # 返回生成好的偏函数
```

# 高阶函数

当一个函数A的某个参数是另一个函数时，则把这个函数A称为是高阶函数

# 返回函数

函数也可以作为返回值。。。

# 匿名函数

匿名函数也称为 lambda函数，也就是没有名字的函数

语法：`lambda 参数表: 返回值`

# 闭包的概念

在函数嵌套的前提下，内层函数引用了外层函数的变量（包括参数）

外层函数，又把内存函数当做返回值进行返回

这个内层函数+所引用的外层变量，称为闭包

常用场景：外层函数，根据不同的参数，来生成不同作用功能的函数

注意：
- 闭包中，如果要修改引用的外部变量
  - 需要使用 `nolocal 变量名` 声明
  - 否则当做闭包内，新定义的变量
- 当闭包内引用了一个后期会发生变化的变量时，一定要注意
  - 当函数被调用的时候，才会真正确定所使用的的值，在此之前，都是以普通的变量标识而存在

# 装饰器

## 装饰器的概念

在函数名以及函数体不改变的前提下，给函数附件一些额外的代码

```python
def zsq(func):
    def inner():
        ...
        func()
        ...
    return inner

@zsq
def xxx():
    ......
    
# @zsq 就相当于 xxx = xsq(xxx)
```

## 装饰器的叠加

从上往下装饰，从下往上执行

## 对有参函数进行装饰

无论什么场景，保证函数调用参数一致

为了通用，可以使用不定长参数，结合拆包操作进行处理

```python
def zsq(func):
    def inner(*args, **kwargs):
        ...
        func(*args, **kwargs)
        ...
    return inner
```



## 对有返回值的函数进行装饰

```python
def zsq(func):
    def inner(*args, **kwargs):
        ...
        ret = func(*args, **kwargs)
        ...
        return ret

    return inner
```

## 带有参数的装饰器

通过 `@装饰器(参数)` 的方式，调用这个函数，并传递参数；并把返回值，再次当做装饰器使用

先计算 @ 后面的内容，把这个内容当做装饰器

# 生成器

是一个特殊的迭代器（迭代器的抽象层级更高）

所以，拥有迭代器的特性：

- 惰性计算数据，节省内存
- 能够记录状态，并通过next()函数，访问下一个状态
- 具备可迭代特性

但是，如果自己打造一个迭代器，比较复杂

## 生成器创建方式

- 生成器表达式：把列表推导式的 `[]`改为 `()`
- 生成器函数：使用 yield 语句，函数的执行结果就是一个生成器

## 产生数据的方式

生成器具备可迭代特性

next() 函数 等价于  `生成器.__next__()`

for in

## send 方法

send方法有一个参数，指的是上一次被挂起的yield语句的返回值

相比于 `__next__()`，可以额外的给yield语句传值

注意第一次调用

## 关闭生成器

`g.close()`

关闭后如果继续调用，会抛出`StopIteration`异常提示

## 注意

如果遇到return，生成器会直接终止

生成器只会遍历一次

# 递归

在函数A内部，直接或者间接调用函数A

# 函数作用域

变量的作用域：

- 变量的作用范围：可操作范围
- Python是静态作用域，也就是说在Python中，变量的作用域源于它在代码中的位置；在不同的位置，可能有不同的命名空间
- 命名空间：
  - 是作用域的体现形式
  - 不同的具体的操作范围
- Python-LEGB
  - L：Local：
    - 函数内的命名空间，
    - 作用范围：当前整个函数体范围
  - E：Enclosing function locals：
    - 外部嵌套函数的命名空间
    - 作用范围：闭包函数
  - G：Global
    - 全局命名空间
    - 作用范围：当前模块（文件）
  - B：Builtin
    - 内建模块命名空间
    - 作用范围：所有模块（文件）
  - 注意：
    - Python中没有块级作用域
    - 块级作用域：代码块中，比如if、while、for后面的代码块
  - LEGB规则：按照 L、E、G、B的顺序进行查找



常见的变量类型：

- 局部变量
  - 在一个函数内部定义的变量
  - 作用域为函数内部
  - 查看局部变量  locals()
- 全局变量
  - 在函数外部，文件最外层定义的变量
  - 作用域为整个文件内部
  - 查看全局变量  globals()
- 注意点
  - 访问原则：从内到外
  - 结构规范：
    - 全局变量
    - 函数定义：使用、修改
    - 后续代码
  - 全局变量和局部变量重名
    - 获取：就近原则
    - 修改：global声明
  - 命名