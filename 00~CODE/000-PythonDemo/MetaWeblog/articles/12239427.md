# 内存概述
## 内存
内存含义：
- 存储器：计算机的组成中，用来存储程序和数据，辅助CPU进行运算处理的重要部分。
- 内存：内部存贮器，暂存程序/数据——掉电丢失 SRAM、DRAM、DDR、DDR2、DDR3。
- 外存：外部存储器，长时间保存程序/数据—掉电不丢ROM、ERRROM、FLASH（NAND、NOR）、硬盘、光盘。

内存是沟通CPU与硬盘的桥梁：
- 暂存放CPU中的运算数据
- 暂存与硬盘等外部存储器交换的数据

## 物理存储器和存储地址空间
有关内存的两个概念：物理存储器和存储地址空间。

物理存储器：实际存在的具体存储器芯片。
- 主板上装插的内存条
- 显示卡上的显示RAM芯片
- 各种适配卡上的RAM芯片和ROM芯片

存储地址空间：对存储器编码的范围。我们在软件上常说的内存是指这一层含义。
- 编码：对每个物理存储单元（一个字节）分配一个号码
- 寻址：可以根据分配的号码找到相应的存储单元，完成数据的读写

## 内存地址

- 将内存抽象成一个很大的一维字符数组。
- 编码就是对内存的每一个字节分配一个32位或64位的编号（与32位或者64位处理器相关）。
- 这个内存编号我们称之为内存地址。

内存中的每一个数据都会分配相应的地址：
- char:占一个字节分配一个地址
- int: 占四个字节分配四个地址
- float、struct、函数、数组等

![](https://img2018.cnblogs.com/blog/1446249/202001/1446249-20200129000442158-694847785.png)

# 指针基础

## 指针和指针变量

- 内存区的每一个字节都有一个编号，这就是“地址”。
- 如果在程序中定义了一个变量，在对程序进行编译或运行时，系统就会给这个变量分配内存单元，并确定它的内存地址(编号)
- 指针的实质就是内存“地址”。指针就是地址，地址就是指针。
- 指针是内存单元的编号，指针变量是存放地址的变量。
- 通常我们叙述时会把指针变量简称为指针，实际他们含义并不一样。

![](https://img2018.cnblogs.com/blog/1446249/202001/1446249-20200129000540934-1883818841.png)

## 指针变量的定义和使用

- 指针也是一种数据类型，指针变量也是一种变量
- 指针变量指向谁，就把谁的地址赋值给指针变量
- “*”操作符操作的是指针变量指向的内存空间

```c
#include <stdio.h>

int main()
{
	int a = 0;
	char b = 100;
	printf("%p, %p\n", &a, &b); //打印a, b的地址

	//int *代表是一种数据类型，int*指针类型，p才是变量名
	//定义了一个指针类型的变量，可以指向一个int类型变量的地址
	int *p;
	p = &a;//将a的地址赋值给变量p，p也是一个变量，值是一个内存地址编号
	printf("%d\n", *p);//p指向了a的地址，*p就是a的值

	char *p1 = &b;
	printf("%c\n", *p1);//*p1指向了b的地址，*p1就是b的值

	return 0;
}
```

注意：`&` 可以取得一个变量在内存中的地址。但是，不能取寄存器变量，因为寄存器变量不在内存里，而在CPU里面，所以是没有地址的。

## 通过指针间接修改变量的值

```c
	int a = 0;
	int b = 11;
	int *p = &a;

	*p = 100;
	printf("a = %d, *p = %d\n", a, *p);

	p = &b;
	*p = 22;
	printf("b = %d, *p = %d\n", b, *p);
```

## 指针大小

- 使用sizeof()测量指针的大小，得到的总是：4或8
- sizeof()测的是指针变量指向存储地址的大小
- 在32位平台，所有的指针（地址）都是32位(4字节)
- 在64位平台，所有的指针（地址）都是64位(8字节)

```c
	int *p1;
	int **p2;
	char *p3;
	char **p4;
	printf("sizeof(p1) = %d\n", sizeof(p1));
	printf("sizeof(p2) = %d\n", sizeof(p2));
	printf("sizeof(p3) = %d\n", sizeof(p3));
	printf("sizeof(p4) = %d\n", sizeof(p4));
	printf("sizeof(double *) = %d\n", sizeof(double *));
```

## 野指针和空指针

指针变量也是变量，是变量就可以任意赋值，不要越界即可（32位为4字节，64位为8字节），但是，任意数值赋值给指针变量没有意义，因为这样的指针就成了野指针，此指针指向的区域是未知(操作系统不允许操作此指针指向的内存区域)。所以，野指针不会直接引发错误，操作野指针指向的内存区域才会出问题

```c
	int a = 100;
	int *p;
	p = a; //把a的值赋值给指针变量p，p为野指针， ok，不会有问题，但没有意义

	p = 0x12345678; //给指针变量p赋值，p为野指针， ok，不会有问题，但没有意义

	*p = 1000;  //操作野指针指向未知区域，内存出问题，err
```

但是，野指针和有效指针变量保存的都是数值，为了标志此指针变量没有指向任何变量(空闲可用)，C语言中，可以把NULL赋值给此指针，这样就标志此指针为空指针，没有任何指针。

```c
int *p = NULL;
```

NULL是一个值为0的宏常量： `#define NULL    ((void *)0)`

## 万能指针 `void *`

`void *` 指针可以指向任意变量的内存空间：

```c
	void *p = NULL;

	int a = 10;
	p = (void *)&a; //指向变量时，最好转换为void *

	//使用指针变量指向的内存时，转换为int *
	*( (int *)p ) = 11;
	printf("a = %d\n", a);
```

## const修饰的指针变量

```c
	int a = 100;
	int b = 200;

        //指向常量的指针
	//修饰*，指针指向内存区域不能修改，指针指向可以变
	const int *p1 = &a; //等价于int const *p1 = &a;
	//*p1 = 111; //err
	p1 = &b; //ok

        //指针常量
	//修饰p1，指针指向不能变，指针指向的内存可以修改
	int * const p2 = &a;
	//p2 = &b; //err
	*p2 = 222; //ok
```

# 指针和数组

## 数组名

数组名字是数组的首元素地址，但它是一个常量，且不能修改

## 指针的加减运算

指针的加减并不是存储的值的加减，而是代表着指针的移位，移位的大小由指针的类型决定

- `p + i` 相当于 `&p[i]`
- `*(p + i)` 相当于 `p[i]`

```c
int a[5] = {1,2,3,4,5};
int *p = a; // p这里就是数组第一个元素的地址

// *p 取出第一个元素的值
// p+1 指向数组的第二个元素
// *(p+1) 取出数组第二个元素的值
// 总结：*(p+i) 相当于 p[i]
```

## 指针数组

指针数组，它是数组，数组的每个元素都是指针类型，仅此而已

## 多级指针

指针也是一个变量，也有地址，也可以通过另一个指针存储这个地址

存储指针的地址的指针就叫做多级指针

# 指针与函数

函数名是一个地址，所以指针也可以指向函数名

指针可以用来给函数传参：这样在函数中就可以通过形参修改外部的数据

指针可以作为函数的返回值：返回一个地址

# 指针和字符串

字符串常量，例如：`"Hello"` 直接用 `%d` 或者 `%p` 打印出来发现是一个数字，因为字符串常量也保存在某个内存块中，也有一个地址

可以用字符指针来指向字符串，因为字符串的地址也是字符串中第一个字符的地址
