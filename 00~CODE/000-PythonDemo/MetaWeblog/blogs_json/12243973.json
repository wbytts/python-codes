{'dateCreated': <DateTime '20200130T21:11:00' at 0x1a4f299d788>, 'description': '前提：输入图像的大小和类型必须一致\n越界处理：\n- 大于255，则会减去255\n- 小于0，则等于0\n\n# 基本计算，加减乘除\n```c++\n#include <opencv2/opencv.hpp>\n#include <iostream>\n\nusing namespace cv;\nusing namespace std;\n\nint main(int argc, char** argv)\n{\n    Mat src1 = imread("f:/temp/images/WindowsLogo.jpg");\n    Mat src2 = imread("f:/temp/images/LinuxLogo.jpg");\n    //namedWindow("003-windowsSrc", WINDOW_AUTOSIZE);\n    //namedWindow("003-linuxSrc", WINDOW_AUTOSIZE);\n    //imshow("003-windowsSrc", src1);\n    //imshow("003-linuxSrc", src2);\n\n    /*\n    Mat dst1;// **\n    add(src1, src2, dst1);\n    imshow("add", dst1);\n\n    Mat dst2; // 减\n    subtract(src1, src2, dst2);\n    imshow("subtract", dst2);\n\n    Mat dst3; // 乘\n    multiply(src1, src2, dst3);\n    imshow("multiply", dst3);\n\n    Mat dst4; // 除\n    divide(src1, src2, dst4);\n    imshow("divide", dst4);\n    */\n    Mat src = imread("f:/temp/images/butterfly.jpg");\n    imshow("butterfly.jpg", src);\n    Mat black = Mat::zeros(src.size(), src.type());\n    black = Scalar(40, 40, 40);\n    Mat dst;\n    // 加或减，改变图像的亮度\n    //add(src, black, dst);\n    subtract(src, black, dst);\n    //imshow("dst", dst);\n\n    Mat dst2;\n    black = Scalar(127, 127, 127);\n    // 让两个图像以不同的权重相加，然后加上一个常量的值\n    // 权重可以给负数\n    addWeighted(src, 1.2, black, 0.5, 0, dst2);\n    imshow("dst2", dst2);\n\n    Mat dst3;\n    addWeighted(src1, 1, src2, 0.5, 0, dst3);\n    imshow("src1+src2", dst3);\n\n    waitKey(0);\n    destroyAllWindows();\n\n    return 0;\n}\n```\n\n# 基本位操作\n\n```c++\n#include <opencv2/opencv.hpp>\n#include <iostream>\n\nusing namespace cv;\nusing namespace std;\n\nint main(int argc, char** argv)\n{\n    Mat src = imread("f:/images/apple.jpg");\n    Mat src1 = imread("f:/images/WindowsLogo.jpg"); \n    Mat src2 = imread("f:/images/LinuxLogo.jpg");\n\n    imshow("src", src);\n\n    // 位操作\n    // 图像取反\n    Mat m1;\n    bitwise_not(src, m1, Mat());\n    imshow("bitwise_not", m1);\n\n    Mat m2;\n    Mat mask = Mat::zeros(src.size(), CV_8UC1);\n    // 参照mask的像素值进行取反\n    // mask如果全是0的话，则不取反\n    bitwise_not(src, m2, mask);\n    imshow("bitwise_not---mask", m2);\n\n    Mat m3;\n    Mat mask2 = Mat::zeros(src.size(), CV_8UC1);\n    int w = src.cols / 2;\n    int h = src.rows / 2;\n    for (int row = 0; row < h; row++) {\n        for (int col = 0; col < w; col++) {\n            mask2.at<uchar>(row, col) = 255;\n        }\n    }\n    imshow("mask2", mask2);\n    bitwise_not(src, m3, mask2);\n    imshow("m3 bitwise_not", m3);\n\n    // 与操作\n    Mat m4;\n    bitwise_and(src1, src2, m4);\n    imshow("m4 bitwise_and", m4);\n\n    // 或操作\n    Mat m5;\n    bitwise_or(src1, src2, m5);\n    imshow("m5 bitwise_or", m5);\n\n    // 异或操作\n    Mat m6;\n    bitwise_xor(src1, src2, m6);\n    imshow("m6 bitwise_xor", m6);\n\n    // 参数 mask：取ROI区域\n    // 位运算的最后一个参数都可以给出一个mask\n\n    waitKey(0);\n    destroyAllWindows();\n\n    return 0;\n}\n```\n', 'title': 'opencv：图像的算术操作', 'categories': ['[随笔分类]OpenCV'], 'enclosure': {'length': 0}, 'link': 'https://www.cnblogs.com/wbyixx/p/12243973.html', 'permalink': 'https://www.cnblogs.com/wbyixx/p/12243973.html', 'postid': '12243973', 'source': {}, 'userid': '-2'}