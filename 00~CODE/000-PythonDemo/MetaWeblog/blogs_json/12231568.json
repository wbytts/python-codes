{'dateCreated': <DateTime '20200123T22:19:00' at 0x1a4f29c9f08>, 'description': '# 基本理论\n\n## 什么是对象\n\n万物皆对象\n\n对象是具体的事物\n\n- 拥有属性、行为\n- 把许多零散的东西，封装成为一个整体\n\nPython中一切东西都是对象，Python是一门特别彻底的面向对象编程语言（OOP）\n\n其他编程语言很多还分基本类型和对象类型，而在python中，只有对象类型\n\n## 面向过程 & 面向对象\n\n两者都是解决问题的思路、思想，面向对象本身是面向过程的封装\n\n- 面向过程：在解决问题的时候，关注的是解决问题的每一个过程（步骤）\n  - 按照步骤划分\n  - 摆一个任务，分解成具体的每一个步骤\n- 面向对象：在解决问题的时候，关注的是解决问题所需要的对象\n  - 按照功能对象进行划分\n  - 找到对象，确定对象属性和行为\n- 如何从面向过程到面向对象：\n  - 列举任务步骤\n  - 分离步骤中的对象和功能代码块\n  - 将功能代码划分到具体对象中\n  - 根据对象以及具体的行为，抽取出类\n\n# 类\n\n## 什么是类\n\n类是某一类具体对象特征的抽象\n\n## 类的作用\n\n根据抽象的类，生产具体的对象\n\n## 类的组成\n\n名称、属性、方法\n\n注意：\n\n- 属性和方法，都是抽象的概念\n- 在产生对象之后，对象才拥有具体的属性值，和方法实现\n\n## 对象和类的关系\n\n对象 -- 抽象 -- 类\n\n类 -- 实例化 -- 对象\n\n## 定义类\n\n经典类的定义：\n\n```python\nclass 类名:\n    ......\n```\n\n## 创建一个对象\n\n```python\nobj = 类名()\n```\n\n创建对象时的底层运作：\n\n- 首先会在内存中开辟一段空间（类的定义也会占用内存）\n- 通过类变量获取类名：`xxx.__name__`\n- 通过对象获取类：`xxx.__class__`\n\n# 属性相关\n\n## 属性和变量的区别\n\n概念：\n\n- 变量是：可以改变的值\n- 属性是：属于某个对象的特征\n\n访问权限：\n\n- 变量：根据作用域不同，存在不同的访问权限\n- 属性：只能通过对象来进行访问\n  - 对象也是通过变量来引用，也同样有作用域权限\n\n判断依据：\n\n- 宿主是否存在\n\n## 添加属性\n\n1. 直接通过对象，动态添加\n   - 语法：`对象.属性 = 值`\n2. 通过类的初始化方法（构造方法）\n   - `__init__()`\n\n\n\n增加了一个属性之后，内存中先开辟一段空间存储属性值，然后在对象的空间里存储这个值对象的引用变量\n\n## 访问属性\n\n直接通过`对象.属性` 访问\n\npython提供了一个 `__dict__` 属性，是一个字典，里面包含了现在这个对象里的所有属性\n\n## 修改属性\n\n修改属性值：`对象.属性 = 值`\n\n## 删除属性\n\n`del 对象.属性`\n\n## 类属性\n\n增加类属性：\n\n- `类名.属性 = 值`\n- 在类中，直接写 `属性 = 值`\n\n查看类属性：\n\n- `类名.属性`\n- 类属性也可以通过对象来访问：`对象.类属性`\n- 对象属性查找机制：\n  - 优先到对象自身去查找属性，找到则结束\n  - 如果没找到，则根据`__class__`找到对象对应的类，找这个类的属性\n\n修改类属性：\n\n- 通过类名进行修改：`类名.属性 = 值`\n- `对象.__class__.属性 = 值`\n- 注意：不能直接通过对象进行修改！ `对象.属性 = xxx` 是对象的增加属性和修改属性的语法\n\n查看所有类属性：`类名.__dict__`\n\n删除类属性：\n\n- `del 类名.属性`\n- 不能通过对象删除，del只能删除对象的直系属性\n\n类属性的内存存储问题：\n\n- 属性都存储在一个字典中，这个字典是实际存在的，可以通过 `__dict__` 进行访问\n- `类.__dict__`是一个只读属性\n- 总结：\n  - 一般情况下，属性存储在 `__dict__` 这个字典中，有些内置对象没有这个属性\n  - 一般对象可以直接修改 `__dict__` 属性\n  - 但是类对象的 `__dict__` 是只读的，默认无法修改，可以通过setattr的方法修改\n\n类属性被各个对象共享\n\n## 限制对象可以添加的属性\n\n在类中写上：`__slots__ = [......]`\n\n后续通过类创建的对象，都只能添加指定的属性\n\n# 方法相关\n\n## 类中方法定义概述\n\n描述一个目标的行为动作\n\n和函数非常类似：\n\n- 都封装了一系列行为动作\n- 都可以在被调用之后，执行一系列行为动作\n- 最主要的区别就是：调用方式\n\n方法的划分：\n- 实例方法：默认第一个参数需要接收到一个实例\n- 类方法：默认第一个参数需要接收到一个类\n- 静态方法：第一个参数什么也不接收\n\n注意：\n- 划分依据是：方法的第一个参数\n- 不管是哪一种方法，都是存储在类中的\n- 不同类型方法的调用方式不同\n\n## 定义方法\n\n定义实例方法：\n```python\nclass A:\n    def shili(self):\n        pass\n```\n\n定义类方法：\n```python\nclass A:\n    @classmethod\n    def lei(cls):\n        pass\n```\n\n定义静态方法：\n```python\nclass A:\n    @taticmethod\n    def jingtai():\n        pass\n```\n\n## 调用方法\n```python\na = A()\n\na.shili() # 调用实例方法\nA.lei() # 调用类方法\na.lei() # 实例也可以调用类方法\nA.jingtai() # 静态方法也是通过类调用\n```\n\n不管是自己传递，还是解释器帮我们处理，最重要保证不同类型的方法第一个参数接收到的是它们想要的类型\n\n## 实例方法\n\n## 类方法\n\n## 静态方法\n\n## 不同类型方法中访问不同类型的属性\n', 'title': 'Python：面向对象基础', 'categories': ['[随笔分类]Python~语法'], 'enclosure': {'length': 0}, 'link': 'https://www.cnblogs.com/wbyixx/p/12231568.html', 'permalink': 'https://www.cnblogs.com/wbyixx/p/12231568.html', 'postid': '12231568', 'source': {}, 'userid': '-2'}