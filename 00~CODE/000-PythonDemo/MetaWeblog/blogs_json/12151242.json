{'dateCreated': <DateTime '20200105T02:24:00' at 0x1a4f2a05b88>, 'description': '转载自：https://github.com/whvcse/RedisUtil\n\n# 代码\n\n## ProtoStuffSerializerUtil.java\n```java\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.util.List;\nimport com.dyuproject.protostuff.LinkedBuffer;\nimport com.dyuproject.protostuff.ProtostuffIOUtil;\nimport com.dyuproject.protostuff.Schema;\nimport com.dyuproject.protostuff.runtime.RuntimeSchema;\n/**\n * ProtoStuffSerializerUtil\n *\n * @author Sirius\n * @date 2019-1-8\n */\npublic class ProtoStuffSerializerUtil {\n    /**\n     * 序列化对象\n     * @param obj\n     * @return\n     */\n    public static <T> byte[] serialize(T obj) {\n        if (obj == null) {\n            throw new RuntimeException("序列化对象(" + obj + ")!");\n        }\n        @SuppressWarnings("unchecked")\n        Schema<T> schema = (Schema<T>) RuntimeSchema.getSchema(obj.getClass());\n        LinkedBuffer buffer = LinkedBuffer.allocate(1024 * 1024);\n        byte[] protostuff = null;\n        try {\n            protostuff = ProtostuffIOUtil.toByteArray(obj, schema, buffer);\n        } catch (Exception e) {\n            throw new RuntimeException("序列化(" + obj.getClass() + ")对象(" + obj + ")发生异常!", e);\n        } finally {\n            buffer.clear();\n        }\n        return protostuff;\n    }\n\n    /**\n     * 反序列化对象\n     * @param paramArrayOfByte\n     * @param targetClass\n     * @return\n     */\n    public static <T> T deserialize(byte[] paramArrayOfByte, Class<T> targetClass) {\n        if (paramArrayOfByte == null || paramArrayOfByte.length == 0) {\n            throw new RuntimeException("反序列化对象发生异常,byte序列为空!");\n        }\n        T instance = null;\n        try {\n            instance = targetClass.newInstance();\n        } catch (InstantiationException  e1) {\n            throw new RuntimeException("反序列化过程中依据类型创建对象失败!", e1);\n        } catch(IllegalAccessException e2){\n            throw new RuntimeException("反序列化过程中依据类型创建对象失败!", e2);\n        }\n        Schema<T> schema = RuntimeSchema.getSchema(targetClass);\n        ProtostuffIOUtil.mergeFrom(paramArrayOfByte, instance, schema);\n        return instance;\n    }\n\n    /**\n     * 序列化列表\n     * @param objList\n     * @return\n     */\n    public static <T> byte[] serializeList(List<T> objList) {\n        if (objList == null || objList.isEmpty()) {\n            throw new RuntimeException("序列化对象列表(" + objList + ")参数异常!");\n        }\n        @SuppressWarnings("unchecked")\n        Schema<T> schema = (Schema<T>) RuntimeSchema.getSchema(objList.get(0).getClass());\n        LinkedBuffer buffer = LinkedBuffer.allocate(1024 * 1024);\n        byte[] protostuff = null;\n        ByteArrayOutputStream bos = null;\n        try {\n            bos = new ByteArrayOutputStream();\n            ProtostuffIOUtil.writeListTo(bos, objList, schema, buffer);\n            protostuff = bos.toByteArray();\n        } catch (Exception e) {\n            throw new RuntimeException("序列化对象列表(" + objList + ")发生异常!", e);\n        } finally {\n            buffer.clear();\n            try {\n                if (bos != null) {\n                    bos.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        return protostuff;\n    }\n\n    /**\n     * 反序列化列表\n     * @param paramArrayOfByte\n     * @param targetClass\n     * @return\n     */\n    public static <T> List<T> deserializeList(byte[] paramArrayOfByte, Class<T> targetClass) {\n        if (paramArrayOfByte == null || paramArrayOfByte.length == 0) {\n            throw new RuntimeException("反序列化对象发生异常,byte序列为空!");\n        }\n\n        Schema<T> schema = RuntimeSchema.getSchema(targetClass);\n        List<T> result = null;\n        try {\n            result = ProtostuffIOUtil.parseListFrom(new ByteArrayInputStream(paramArrayOfByte), schema);\n        } catch (IOException e) {\n            throw new RuntimeException("反序列化对象列表发生异常!", e);\n        }\n        return result;\n    }\n\n}\n```\n\n## RedisUtil.java\n\n```java\nimport org.springframework.data.redis.connection.DataType;\nimport org.springframework.data.redis.core.Cursor;\nimport org.springframework.data.redis.core.ScanOptions;\nimport org.springframework.data.redis.core.StringRedisTemplate;\nimport org.springframework.data.redis.core.ZSetOperations.TypedTuple;\n\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * Redis工具类\n * \n * @author WangFan\n * @date 2018-02-24 下午03:09:50\n * @version 1.1 (GitHub文档: https://github.com/whvcse/RedisUtil )\n */\npublic class RedisUtil {\n\tprivate StringRedisTemplate redisTemplate;\n\n\tpublic void setRedisTemplate(StringRedisTemplate redisTemplate) {\n\t\tthis.redisTemplate = redisTemplate;\n\t}\n\n\tpublic StringRedisTemplate getRedisTemplate() {\n\t\treturn this.redisTemplate;\n\t}\n\n\t/** -------------------key相关操作--------------------- */\n\n\t/**\n\t * 删除key\n\t * \n\t * @param key\n\t */\n\tpublic void delete(String key) {\n\t\tredisTemplate.delete(key);\n\t}\n\n\t/**\n\t * 批量删除key\n\t * \n\t * @param keys\n\t */\n\tpublic void delete(Collection<String> keys) {\n\t\tredisTemplate.delete(keys);\n\t}\n\n\t/**\n\t * 序列化key\n\t * \n\t * @param key\n\t * @return\n\t */\n\tpublic byte[] dump(String key) {\n\t\treturn redisTemplate.dump(key);\n\t}\n\n\t/**\n\t * 是否存在key\n\t * \n\t * @param key\n\t * @return\n\t */\n\tpublic Boolean hasKey(String key) {\n\t\treturn redisTemplate.hasKey(key);\n\t}\n\n\t/**\n\t * 设置过期时间\n\t * \n\t * @param key\n\t * @param timeout\n\t * @param unit\n\t * @return\n\t */\n\tpublic Boolean expire(String key, long timeout, TimeUnit unit) {\n\t\treturn redisTemplate.expire(key, timeout, unit);\n\t}\n\n\t/**\n\t * 设置过期时间\n\t * \n\t * @param key\n\t * @param date\n\t * @return\n\t */\n\tpublic Boolean expireAt(String key, Date date) {\n\t\treturn redisTemplate.expireAt(key, date);\n\t}\n\n\t/**\n\t * 查找匹配的key\n\t * \n\t * @param pattern\n\t * @return\n\t */\n\tpublic Set<String> keys(String pattern) {\n\t\treturn redisTemplate.keys(pattern);\n\t}\n\n\t/**\n\t * 将当前数据库的 key 移动到给定的数据库 db 当中\n\t * \n\t * @param key\n\t * @param dbIndex\n\t * @return\n\t */\n\tpublic Boolean move(String key, int dbIndex) {\n\t\treturn redisTemplate.move(key, dbIndex);\n\t}\n\n\t/**\n\t * 移除 key 的过期时间，key 将持久保持\n\t * \n\t * @param key\n\t * @return\n\t */\n\tpublic Boolean persist(String key) {\n\t\treturn redisTemplate.persist(key);\n\t}\n\n\t/**\n\t * 返回 key 的剩余的过期时间\n\t * \n\t * @param key\n\t * @param unit\n\t * @return\n\t */\n\tpublic Long getExpire(String key, TimeUnit unit) {\n\t\treturn redisTemplate.getExpire(key, unit);\n\t}\n\n\t/**\n\t * 返回 key 的剩余的过期时间\n\t * \n\t * @param key\n\t * @return\n\t */\n\tpublic Long getExpire(String key) {\n\t\treturn redisTemplate.getExpire(key);\n\t}\n\n\t/**\n\t * 从当前数据库中随机返回一个 key\n\t * \n\t * @return\n\t */\n\tpublic String randomKey() {\n\t\treturn redisTemplate.randomKey();\n\t}\n\n\t/**\n\t * 修改 key 的名称\n\t * \n\t * @param oldKey\n\t * @param newKey\n\t */\n\tpublic void rename(String oldKey, String newKey) {\n\t\tredisTemplate.rename(oldKey, newKey);\n\t}\n\n\t/**\n\t * 仅当 newkey 不存在时，将 oldKey 改名为 newkey\n\t * \n\t * @param oldKey\n\t * @param newKey\n\t * @return\n\t */\n\tpublic Boolean renameIfAbsent(String oldKey, String newKey) {\n\t\treturn redisTemplate.renameIfAbsent(oldKey, newKey);\n\t}\n\n\t/**\n\t * 返回 key 所储存的值的类型\n\t * \n\t * @param key\n\t * @return\n\t */\n\tpublic DataType type(String key) {\n\t\treturn redisTemplate.type(key);\n\t}\n\n\t/** -------------------string相关操作--------------------- */\n\n\t/**\n\t * 设置指定 key 的值\n\t * @param key\n\t * @param value\n\t */\n\tpublic void set(String key, String value) {\n\t\tredisTemplate.opsForValue().set(key, value);\n\t}\n\n\t/**\n\t * 获取指定 key 的值\n\t * @param key\n\t * @return\n\t */\n\tpublic String get(String key) {\n\t\treturn redisTemplate.opsForValue().get(key);\n\t}\n\n\t/**\n\t * 返回 key 中字符串值的子字符\n\t * @param key\n\t * @param start\n\t * @param end\n\t * @return\n\t */\n\tpublic String getRange(String key, long start, long end) {\n\t\treturn redisTemplate.opsForValue().get(key, start, end);\n\t}\n\n\t/**\n\t * 将给定 key 的值设为 value ，并返回 key 的旧值(old value)\n\t * \n\t * @param key\n\t * @param value\n\t * @return\n\t */\n\tpublic String getAndSet(String key, String value) {\n\t\treturn redisTemplate.opsForValue().getAndSet(key, value);\n\t}\n\n\t/**\n\t * 对 key 所储存的字符串值，获取指定偏移量上的位(bit)\n\t * \n\t * @param key\n\t * @param offset\n\t * @return\n\t */\n\tpublic Boolean getBit(String key, long offset) {\n\t\treturn redisTemplate.opsForValue().getBit(key, offset);\n\t}\n\n\t/**\n\t * 批量获取\n\t * \n\t * @param keys\n\t * @return\n\t */\n\tpublic List<String> multiGet(Collection<String> keys) {\n\t\treturn redisTemplate.opsForValue().multiGet(keys);\n\t}\n\n\t/**\n\t * 设置ASCII码, 字符串\'a\'的ASCII码是97, 转为二进制是\'01100001\', 此方法是将二进制第offset位值变为value\n\t * \n\t * @param key\n\t * @param postion\n\t *            位置\n\t * @param value\n\t *            值,true为1, false为0\n\t * @return\n\t */\n\tpublic boolean setBit(String key, long offset, boolean value) {\n\t\treturn redisTemplate.opsForValue().setBit(key, offset, value);\n\t}\n\n\t/**\n\t * 将值 value 关联到 key ，并将 key 的过期时间设为 timeout\n\t * \n\t * @param key\n\t * @param value\n\t * @param timeout\n\t *            过期时间\n\t * @param unit\n\t *            时间单位, 天:TimeUnit.DAYS 小时:TimeUnit.HOURS 分钟:TimeUnit.MINUTES\n\t *            秒:TimeUnit.SECONDS 毫秒:TimeUnit.MILLISECONDS\n\t */\n\tpublic void setEx(String key, String value, long timeout, TimeUnit unit) {\n\t\tredisTemplate.opsForValue().set(key, value, timeout, unit);\n\t}\n\n\t/**\n\t * 只有在 key 不存在时设置 key 的值\n\t * \n\t * @param key\n\t * @param value\n\t * @return 之前已经存在返回false,不存在返回true\n\t */\n\tpublic boolean setIfAbsent(String key, String value) {\n\t\treturn redisTemplate.opsForValue().setIfAbsent(key, value);\n\t}\n\n\t/**\n\t * 用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始\n\t * \n\t * @param key\n\t * @param value\n\t * @param offset\n\t *            从指定位置开始覆写\n\t */\n\tpublic void setRange(String key, String value, long offset) {\n\t\tredisTemplate.opsForValue().set(key, value, offset);\n\t}\n\n\t/**\n\t * 获取字符串的长度\n\t * \n\t * @param key\n\t * @return\n\t */\n\tpublic Long size(String key) {\n\t\treturn redisTemplate.opsForValue().size(key);\n\t}\n\n\t/**\n\t * 批量添加\n\t * \n\t * @param maps\n\t */\n\tpublic void multiSet(Map<String, String> maps) {\n\t\tredisTemplate.opsForValue().multiSet(maps);\n\t}\n\n\t/**\n\t * 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在\n\t * \n\t * @param maps\n\t * @return 之前已经存在返回false,不存在返回true\n\t */\n\tpublic boolean multiSetIfAbsent(Map<String, String> maps) {\n\t\treturn redisTemplate.opsForValue().multiSetIfAbsent(maps);\n\t}\n\n\t/**\n\t * 增加(自增长), 负数则为自减\n\t * \n\t * @param key\n\t * @param value\n\t * @return\n\t */\n\tpublic Long incrBy(String key, long increment) {\n\t\treturn redisTemplate.opsForValue().increment(key, increment);\n\t}\n\n\t/**\n\t * \n\t * @param key\n\t * @param value\n\t * @return\n\t */\n\tpublic Double incrByFloat(String key, double increment) {\n\t\treturn redisTemplate.opsForValue().increment(key, increment);\n\t}\n\n\t/**\n\t * 追加到末尾\n\t * \n\t * @param key\n\t * @param value\n\t * @return\n\t */\n\tpublic Integer append(String key, String value) {\n\t\treturn redisTemplate.opsForValue().append(key, value);\n\t}\n\n\t/** -------------------hash相关操作------------------------- */\n\n\t/**\n\t * 获取存储在哈希表中指定字段的值\n\t * \n\t * @param key\n\t * @param field\n\t * @return\n\t */\n\tpublic Object hGet(String key, String field) {\n\t\treturn redisTemplate.opsForHash().get(key, field);\n\t}\n\n\t/**\n\t * 获取所有给定字段的值\n\t * \n\t * @param key\n\t * @return\n\t */\n\tpublic Map<Object, Object> hGetAll(String key) {\n\t\treturn redisTemplate.opsForHash().entries(key);\n\t}\n\n\t/**\n\t * 获取所有给定字段的值\n\t * \n\t * @param key\n\t * @param fields\n\t * @return\n\t */\n\tpublic List<Object> hMultiGet(String key, Collection<Object> fields) {\n\t\treturn redisTemplate.opsForHash().multiGet(key, fields);\n\t}\n\n\tpublic void hPut(String key, String hashKey, String value) {\n\t\tredisTemplate.opsForHash().put(key, hashKey, value);\n\t}\n\n\tpublic void hPutAll(String key, Map<String, String> maps) {\n\t\tredisTemplate.opsForHash().putAll(key, maps);\n\t}\n\n\t/**\n\t * 仅当hashKey不存在时才设置\n\t * \n\t * @param key\n\t * @param hashKey\n\t * @param value\n\t * @return\n\t */\n\tpublic Boolean hPutIfAbsent(String key, String hashKey, String value) {\n\t\treturn redisTemplate.opsForHash().putIfAbsent(key, hashKey, value);\n\t}\n\n\t/**\n\t * 删除一个或多个哈希表字段\n\t * \n\t * @param key\n\t * @param fields\n\t * @return\n\t */\n\tpublic Long hDelete(String key, Object... fields) {\n\t\treturn redisTemplate.opsForHash().delete(key, fields);\n\t}\n\n\t/**\n\t * 查看哈希表 key 中，指定的字段是否存在\n\t * \n\t * @param key\n\t * @param field\n\t * @return\n\t */\n\tpublic boolean hExists(String key, String field) {\n\t\treturn redisTemplate.opsForHash().hasKey(key, field);\n\t}\n\n\t/**\n\t * 为哈希表 key 中的指定字段的整数值加上增量 increment\n\t * \n\t * @param key\n\t * @param field\n\t * @param increment\n\t * @return\n\t */\n\tpublic Long hIncrBy(String key, Object field, long increment) {\n\t\treturn redisTemplate.opsForHash().increment(key, field, increment);\n\t}\n\n\t/**\n\t * 为哈希表 key 中的指定字段的整数值加上增量 increment\n\t * \n\t * @param key\n\t * @param field\n\t * @param delta\n\t * @return\n\t */\n\tpublic Double hIncrByFloat(String key, Object field, double delta) {\n\t\treturn redisTemplate.opsForHash().increment(key, field, delta);\n\t}\n\n\t/**\n\t * 获取所有哈希表中的字段\n\t * \n\t * @param key\n\t * @return\n\t */\n\tpublic Set<Object> hKeys(String key) {\n\t\treturn redisTemplate.opsForHash().keys(key);\n\t}\n\n\t/**\n\t * 获取哈希表中字段的数量\n\t * \n\t * @param key\n\t * @return\n\t */\n\tpublic Long hSize(String key) {\n\t\treturn redisTemplate.opsForHash().size(key);\n\t}\n\n\t/**\n\t * 获取哈希表中所有值\n\t * \n\t * @param key\n\t * @return\n\t */\n\tpublic List<Object> hValues(String key) {\n\t\treturn redisTemplate.opsForHash().values(key);\n\t}\n\n\t/**\n\t * 迭代哈希表中的键值对\n\t * \n\t * @param key\n\t * @param options\n\t * @return\n\t */\n\tpublic Cursor<Entry<Object, Object>> hScan(String key, ScanOptions options) {\n\t\treturn redisTemplate.opsForHash().scan(key, options);\n\t}\n\n\t/** ------------------------list相关操作---------------------------- */\n\n\t/**\n\t * 通过索引获取列表中的元素\n\t * \n\t * @param key\n\t * @param index\n\t * @return\n\t */\n\tpublic String lIndex(String key, long index) {\n\t\treturn redisTemplate.opsForList().index(key, index);\n\t}\n\n\t/**\n\t * 获取列表指定范围内的元素\n\t * \n\t * @param key\n\t * @param start\n\t *            开始位置, 0是开始位置\n\t * @param end\n\t *            结束位置, -1返回所有\n\t * @return\n\t */\n\tpublic List<String> lRange(String key, long start, long end) {\n\t\treturn redisTemplate.opsForList().range(key, start, end);\n\t}\n\n\t/**\n\t * 存储在list头部\n\t * \n\t * @param key\n\t * @param value\n\t * @return\n\t */\n\tpublic Long lLeftPush(String key, String value) {\n\t\treturn redisTemplate.opsForList().leftPush(key, value);\n\t}\n\n\t/**\n\t * \n\t * @param key\n\t * @param value\n\t * @return\n\t */\n\tpublic Long lLeftPushAll(String key, String... value) {\n\t\treturn redisTemplate.opsForList().leftPushAll(key, value);\n\t}\n\n\t/**\n\t * \n\t * @param key\n\t * @param value\n\t * @return\n\t */\n\tpublic Long lLeftPushAll(String key, Collection<String> value) {\n\t\treturn redisTemplate.opsForList().leftPushAll(key, value);\n\t}\n\n\t/**\n\t * 当list存在的时候才加入\n\t * \n\t * @param key\n\t * @param value\n\t * @return\n\t */\n\tpublic Long lLeftPushIfPresent(String key, String value) {\n\t\treturn redisTemplate.opsForList().leftPushIfPresent(key, value);\n\t}\n\n\t/**\n\t * 如果pivot存在,再pivot前面添加\n\t * \n\t * @param key\n\t * @param pivot\n\t * @param value\n\t * @return\n\t */\n\tpublic Long lLeftPush(String key, String pivot, String value) {\n\t\treturn redisTemplate.opsForList().leftPush(key, pivot, value);\n\t}\n\n\t/**\n\t * \n\t * @param key\n\t * @param value\n\t * @return\n\t */\n\tpublic Long lRightPush(String key, String value) {\n\t\treturn redisTemplate.opsForList().rightPush(key, value);\n\t}\n\n\t/**\n\t * \n\t * @param key\n\t * @param value\n\t * @return\n\t */\n\tpublic Long lRightPushAll(String key, String... value) {\n\t\treturn redisTemplate.opsForList().rightPushAll(key, value);\n\t}\n\n\t/**\n\t * \n\t * @param key\n\t * @param value\n\t * @return\n\t */\n\tpublic Long lRightPushAll(String key, Collection<String> value) {\n\t\treturn redisTemplate.opsForList().rightPushAll(key, value);\n\t}\n\n\t/**\n\t * 为已存在的列表添加值\n\t * \n\t * @param key\n\t * @param value\n\t * @return\n\t */\n\tpublic Long lRightPushIfPresent(String key, String value) {\n\t\treturn redisTemplate.opsForList().rightPushIfPresent(key, value);\n\t}\n\n\t/**\n\t * 在pivot元素的右边添加值\n\t * \n\t * @param key\n\t * @param pivot\n\t * @param value\n\t * @return\n\t */\n\tpublic Long lRightPush(String key, String pivot, String value) {\n\t\treturn redisTemplate.opsForList().rightPush(key, pivot, value);\n\t}\n\n\t/**\n\t * 通过索引设置列表元素的值\n\t * \n\t * @param key\n\t * @param index\n\t *            位置\n\t * @param value\n\t */\n\tpublic void lSet(String key, long index, String value) {\n\t\tredisTemplate.opsForList().set(key, index, value);\n\t}\n\n\t/**\n\t * 移出并获取列表的第一个元素\n\t * \n\t * @param key\n\t * @return 删除的元素\n\t */\n\tpublic String lLeftPop(String key) {\n\t\treturn redisTemplate.opsForList().leftPop(key);\n\t}\n\n\t/**\n\t * 移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止\n\t * \n\t * @param key\n\t * @param timeout\n\t *            等待时间\n\t * @param unit\n\t *            时间单位\n\t * @return\n\t */\n\tpublic String lBLeftPop(String key, long timeout, TimeUnit unit) {\n\t\treturn redisTemplate.opsForList().leftPop(key, timeout, unit);\n\t}\n\n\t/**\n\t * 移除并获取列表最后一个元素\n\t * \n\t * @param key\n\t * @return 删除的元素\n\t */\n\tpublic String lRightPop(String key) {\n\t\treturn redisTemplate.opsForList().rightPop(key);\n\t}\n\n\t/**\n\t * 移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止\n\t * \n\t * @param key\n\t * @param timeout\n\t *            等待时间\n\t * @param unit\n\t *            时间单位\n\t * @return\n\t */\n\tpublic String lBRightPop(String key, long timeout, TimeUnit unit) {\n\t\treturn redisTemplate.opsForList().rightPop(key, timeout, unit);\n\t}\n\n\t/**\n\t * 移除列表的最后一个元素，并将该元素添加到另一个列表并返回\n\t * \n\t * @param sourceKey\n\t * @param destinationKey\n\t * @return\n\t */\n\tpublic String lRightPopAndLeftPush(String sourceKey, String destinationKey) {\n\t\treturn redisTemplate.opsForList().rightPopAndLeftPush(sourceKey,\n\t\t\t\tdestinationKey);\n\t}\n\n\t/**\n\t * 从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止\n\t * \n\t * @param sourceKey\n\t * @param destinationKey\n\t * @param timeout\n\t * @param unit\n\t * @return\n\t */\n\tpublic String lBRightPopAndLeftPush(String sourceKey, String destinationKey,\n\t\t\tlong timeout, TimeUnit unit) {\n\t\treturn redisTemplate.opsForList().rightPopAndLeftPush(sourceKey,\n\t\t\t\tdestinationKey, timeout, unit);\n\t}\n\n\t/**\n\t * 删除集合中值等于value得元素\n\t * \n\t * @param key\n\t * @param index\n\t *            index=0, 删除所有值等于value的元素; index>0, 从头部开始删除第一个值等于value的元素;\n\t *            index<0, 从尾部开始删除第一个值等于value的元素;\n\t * @param value\n\t * @return\n\t */\n\tpublic Long lRemove(String key, long index, String value) {\n\t\treturn redisTemplate.opsForList().remove(key, index, value);\n\t}\n\n\t/**\n\t * 裁剪list\n\t * \n\t * @param key\n\t * @param start\n\t * @param end\n\t */\n\tpublic void lTrim(String key, long start, long end) {\n\t\tredisTemplate.opsForList().trim(key, start, end);\n\t}\n\n\t/**\n\t * 获取列表长度\n\t * \n\t * @param key\n\t * @return\n\t */\n\tpublic Long lLen(String key) {\n\t\treturn redisTemplate.opsForList().size(key);\n\t}\n\n\t/** --------------------set相关操作-------------------------- */\n\n\t/**\n\t * set添加元素\n\t * \n\t * @param key\n\t * @param values\n\t * @return\n\t */\n\tpublic Long sAdd(String key, String... values) {\n\t\treturn redisTemplate.opsForSet().add(key, values);\n\t}\n\n\t/**\n\t * set移除元素\n\t * \n\t * @param key\n\t * @param values\n\t * @return\n\t */\n\tpublic Long sRemove(String key, Object... values) {\n\t\treturn redisTemplate.opsForSet().remove(key, values);\n\t}\n\n\t/**\n\t * 移除并返回集合的一个随机元素\n\t * \n\t * @param key\n\t * @return\n\t */\n\tpublic String sPop(String key) {\n\t\treturn redisTemplate.opsForSet().pop(key);\n\t}\n\n\t/**\n\t * 将元素value从一个集合移到另一个集合\n\t * \n\t * @param key\n\t * @param value\n\t * @param destKey\n\t * @return\n\t */\n\tpublic Boolean sMove(String key, String value, String destKey) {\n\t\treturn redisTemplate.opsForSet().move(key, value, destKey);\n\t}\n\n\t/**\n\t * 获取集合的大小\n\t * \n\t * @param key\n\t * @return\n\t */\n\tpublic Long sSize(String key) {\n\t\treturn redisTemplate.opsForSet().size(key);\n\t}\n\n\t/**\n\t * 判断集合是否包含value\n\t * \n\t * @param key\n\t * @param value\n\t * @return\n\t */\n\tpublic Boolean sIsMember(String key, Object value) {\n\t\treturn redisTemplate.opsForSet().isMember(key, value);\n\t}\n\n\t/**\n\t * 获取两个集合的交集\n\t * \n\t * @param key\n\t * @param otherKey\n\t * @return\n\t */\n\tpublic Set<String> sIntersect(String key, String otherKey) {\n\t\treturn redisTemplate.opsForSet().intersect(key, otherKey);\n\t}\n\n\t/**\n\t * 获取key集合与多个集合的交集\n\t * \n\t * @param key\n\t * @param otherKeys\n\t * @return\n\t */\n\tpublic Set<String> sIntersect(String key, Collection<String> otherKeys) {\n\t\treturn redisTemplate.opsForSet().intersect(key, otherKeys);\n\t}\n\n\t/**\n\t * key集合与otherKey集合的交集存储到destKey集合中\n\t * \n\t * @param key\n\t * @param otherKey\n\t * @param destKey\n\t * @return\n\t */\n\tpublic Long sIntersectAndStore(String key, String otherKey, String destKey) {\n\t\treturn redisTemplate.opsForSet().intersectAndStore(key, otherKey,\n\t\t\t\tdestKey);\n\t}\n\n\t/**\n\t * key集合与多个集合的交集存储到destKey集合中\n\t * \n\t * @param key\n\t * @param otherKeys\n\t * @param destKey\n\t * @return\n\t */\n\tpublic Long sIntersectAndStore(String key, Collection<String> otherKeys,\n\t\t\tString destKey) {\n\t\treturn redisTemplate.opsForSet().intersectAndStore(key, otherKeys,\n\t\t\t\tdestKey);\n\t}\n\n\t/**\n\t * 获取两个集合的并集\n\t * \n\t * @param key\n\t * @param otherKeys\n\t * @return\n\t */\n\tpublic Set<String> sUnion(String key, String otherKeys) {\n\t\treturn redisTemplate.opsForSet().union(key, otherKeys);\n\t}\n\n\t/**\n\t * 获取key集合与多个集合的并集\n\t * \n\t * @param key\n\t * @param otherKeys\n\t * @return\n\t */\n\tpublic Set<String> sUnion(String key, Collection<String> otherKeys) {\n\t\treturn redisTemplate.opsForSet().union(key, otherKeys);\n\t}\n\n\t/**\n\t * key集合与otherKey集合的并集存储到destKey中\n\t * \n\t * @param key\n\t * @param otherKey\n\t * @param destKey\n\t * @return\n\t */\n\tpublic Long sUnionAndStore(String key, String otherKey, String destKey) {\n\t\treturn redisTemplate.opsForSet().unionAndStore(key, otherKey, destKey);\n\t}\n\n\t/**\n\t * key集合与多个集合的并集存储到destKey中\n\t * \n\t * @param key\n\t * @param otherKeys\n\t * @param destKey\n\t * @return\n\t */\n\tpublic Long sUnionAndStore(String key, Collection<String> otherKeys,\n\t\t\tString destKey) {\n\t\treturn redisTemplate.opsForSet().unionAndStore(key, otherKeys, destKey);\n\t}\n\n\t/**\n\t * 获取两个集合的差集\n\t * \n\t * @param key\n\t * @param otherKey\n\t * @return\n\t */\n\tpublic Set<String> sDifference(String key, String otherKey) {\n\t\treturn redisTemplate.opsForSet().difference(key, otherKey);\n\t}\n\n\t/**\n\t * 获取key集合与多个集合的差集\n\t * \n\t * @param key\n\t * @param otherKeys\n\t * @return\n\t */\n\tpublic Set<String> sDifference(String key, Collection<String> otherKeys) {\n\t\treturn redisTemplate.opsForSet().difference(key, otherKeys);\n\t}\n\n\t/**\n\t * key集合与otherKey集合的差集存储到destKey中\n\t * \n\t * @param key\n\t * @param otherKey\n\t * @param destKey\n\t * @return\n\t */\n\tpublic Long sDifference(String key, String otherKey, String destKey) {\n\t\treturn redisTemplate.opsForSet().differenceAndStore(key, otherKey,\n\t\t\t\tdestKey);\n\t}\n\n\t/**\n\t * key集合与多个集合的差集存储到destKey中\n\t * \n\t * @param key\n\t * @param otherKeys\n\t * @param destKey\n\t * @return\n\t */\n\tpublic Long sDifference(String key, Collection<String> otherKeys,\n\t\t\tString destKey) {\n\t\treturn redisTemplate.opsForSet().differenceAndStore(key, otherKeys,\n\t\t\t\tdestKey);\n\t}\n\n\t/**\n\t * 获取集合所有元素\n\t * \n\t * @param key\n\t * @param otherKeys\n\t * @param destKey\n\t * @return\n\t */\n\tpublic Set<String> setMembers(String key) {\n\t\treturn redisTemplate.opsForSet().members(key);\n\t}\n\n\t/**\n\t * 随机获取集合中的一个元素\n\t * \n\t * @param key\n\t * @return\n\t */\n\tpublic String sRandomMember(String key) {\n\t\treturn redisTemplate.opsForSet().randomMember(key);\n\t}\n\n\t/**\n\t * 随机获取集合中count个元素\n\t * \n\t * @param key\n\t * @param count\n\t * @return\n\t */\n\tpublic List<String> sRandomMembers(String key, long count) {\n\t\treturn redisTemplate.opsForSet().randomMembers(key, count);\n\t}\n\n\t/**\n\t * 随机获取集合中count个元素并且去除重复的\n\t * \n\t * @param key\n\t * @param count\n\t * @return\n\t */\n\tpublic Set<String> sDistinctRandomMembers(String key, long count) {\n\t\treturn redisTemplate.opsForSet().distinctRandomMembers(key, count);\n\t}\n\n\t/**\n\t * \n\t * @param key\n\t * @param options\n\t * @return\n\t */\n\tpublic Cursor<String> sScan(String key, ScanOptions options) {\n\t\treturn redisTemplate.opsForSet().scan(key, options);\n\t}\n\n\t/**------------------zSet相关操作--------------------------------*/\n\t\n\t/**\n\t * 添加元素,有序集合是按照元素的score值由小到大排列\n\t * \n\t * @param key\n\t * @param value\n\t * @param score\n\t * @return\n\t */\n\tpublic Boolean zAdd(String key, String value, double score) {\n\t\treturn redisTemplate.opsForZSet().add(key, value, score);\n\t}\n\n\t/**\n\t * \n\t * @param key\n\t * @param values\n\t * @return\n\t */\n\tpublic Long zAdd(String key, Set<TypedTuple<String>> values) {\n\t\treturn redisTemplate.opsForZSet().add(key, values);\n\t}\n\n\t/**\n\t * \n\t * @param key\n\t * @param values\n\t * @return\n\t */\n\tpublic Long zRemove(String key, Object... values) {\n\t\treturn redisTemplate.opsForZSet().remove(key, values);\n\t}\n\n\t/**\n\t * 增加元素的score值，并返回增加后的值\n\t * \n\t * @param key\n\t * @param value\n\t * @param delta\n\t * @return\n\t */\n\tpublic Double zIncrementScore(String key, String value, double delta) {\n\t\treturn redisTemplate.opsForZSet().incrementScore(key, value, delta);\n\t}\n\n\t/**\n\t * 返回元素在集合的排名,有序集合是按照元素的score值由小到大排列\n\t * \n\t * @param key\n\t * @param value\n\t * @return 0表示第一位\n\t */\n\tpublic Long zRank(String key, Object value) {\n\t\treturn redisTemplate.opsForZSet().rank(key, value);\n\t}\n\n\t/**\n\t * 返回元素在集合的排名,按元素的score值由大到小排列\n\t * \n\t * @param key\n\t * @param value\n\t * @return\n\t */\n\tpublic Long zReverseRank(String key, Object value) {\n\t\treturn redisTemplate.opsForZSet().reverseRank(key, value);\n\t}\n\n\t/**\n\t * 获取集合的元素, 从小到大排序\n\t * \n\t * @param key\n\t * @param start\n\t *            开始位置\n\t * @param end\n\t *            结束位置, -1查询所有\n\t * @return\n\t */\n\tpublic Set<String> zRange(String key, long start, long end) {\n\t\treturn redisTemplate.opsForZSet().range(key, start, end);\n\t}\n\n\t/**\n\t * 获取集合元素, 并且把score值也获取\n\t * \n\t * @param key\n\t * @param start\n\t * @param end\n\t * @return\n\t */\n\tpublic Set<TypedTuple<String>> zRangeWithScores(String key, long start,\n\t\t\tlong end) {\n\t\treturn redisTemplate.opsForZSet().rangeWithScores(key, start, end);\n\t}\n\n\t/**\n\t * 根据Score值查询集合元素\n\t * \n\t * @param key\n\t * @param min\n\t *            最小值\n\t * @param max\n\t *            最大值\n\t * @return\n\t */\n\tpublic Set<String> zRangeByScore(String key, double min, double max) {\n\t\treturn redisTemplate.opsForZSet().rangeByScore(key, min, max);\n\t}\n\n\t/**\n\t * 根据Score值查询集合元素, 从小到大排序\n\t * \n\t * @param key\n\t * @param min\n\t *            最小值\n\t * @param max\n\t *            最大值\n\t * @return\n\t */\n\tpublic Set<TypedTuple<String>> zRangeByScoreWithScores(String key,\n\t\t\tdouble min, double max) {\n\t\treturn redisTemplate.opsForZSet().rangeByScoreWithScores(key, min, max);\n\t}\n\n\t/**\n\t * \n\t * @param key\n\t * @param min\n\t * @param max\n\t * @param start\n\t * @param end\n\t * @return\n\t */\n\tpublic Set<TypedTuple<String>> zRangeByScoreWithScores(String key,\n\t\t\tdouble min, double max, long start, long end) {\n\t\treturn redisTemplate.opsForZSet().rangeByScoreWithScores(key, min, max,\n\t\t\t\tstart, end);\n\t}\n\n\t/**\n\t * 获取集合的元素, 从大到小排序\n\t * \n\t * @param key\n\t * @param start\n\t * @param end\n\t * @return\n\t */\n\tpublic Set<String> zReverseRange(String key, long start, long end) {\n\t\treturn redisTemplate.opsForZSet().reverseRange(key, start, end);\n\t}\n\n\t/**\n\t * 获取集合的元素, 从大到小排序, 并返回score值\n\t * \n\t * @param key\n\t * @param start\n\t * @param end\n\t * @return\n\t */\n\tpublic Set<TypedTuple<String>> zReverseRangeWithScores(String key,\n\t\t\tlong start, long end) {\n\t\treturn redisTemplate.opsForZSet().reverseRangeWithScores(key, start,\n\t\t\t\tend);\n\t}\n\n\t/**\n\t * 根据Score值查询集合元素, 从大到小排序\n\t * \n\t * @param key\n\t * @param min\n\t * @param max\n\t * @return\n\t */\n\tpublic Set<String> zReverseRangeByScore(String key, double min,\n\t\t\tdouble max) {\n\t\treturn redisTemplate.opsForZSet().reverseRangeByScore(key, min, max);\n\t}\n\n\t/**\n\t * 根据Score值查询集合元素, 从大到小排序\n\t * \n\t * @param key\n\t * @param min\n\t * @param max\n\t * @return\n\t */\n\tpublic Set<TypedTuple<String>> zReverseRangeByScoreWithScores(\n\t\t\tString key, double min, double max) {\n\t\treturn redisTemplate.opsForZSet().reverseRangeByScoreWithScores(key,\n\t\t\t\tmin, max);\n\t}\n\n\t/**\n\t * \n\t * @param key\n\t * @param min\n\t * @param max\n\t * @param start\n\t * @param end\n\t * @return\n\t */\n\tpublic Set<String> zReverseRangeByScore(String key, double min,\n\t\t\tdouble max, long start, long end) {\n\t\treturn redisTemplate.opsForZSet().reverseRangeByScore(key, min, max,\n\t\t\t\tstart, end);\n\t}\n\n\t/**\n\t * 根据score值获取集合元素数量\n\t * \n\t * @param key\n\t * @param min\n\t * @param max\n\t * @return\n\t */\n\tpublic Long zCount(String key, double min, double max) {\n\t\treturn redisTemplate.opsForZSet().count(key, min, max);\n\t}\n\n\t/**\n\t * 获取集合大小\n\t * \n\t * @param key\n\t * @return\n\t */\n\tpublic Long zSize(String key) {\n\t\treturn redisTemplate.opsForZSet().size(key);\n\t}\n\n\t/**\n\t * 获取集合大小\n\t * \n\t * @param key\n\t * @return\n\t */\n\tpublic Long zZCard(String key) {\n\t\treturn redisTemplate.opsForZSet().zCard(key);\n\t}\n\n\t/**\n\t * 获取集合中value元素的score值\n\t * \n\t * @param key\n\t * @param value\n\t * @return\n\t */\n\tpublic Double zScore(String key, Object value) {\n\t\treturn redisTemplate.opsForZSet().score(key, value);\n\t}\n\n\t/**\n\t * 移除指定索引位置的成员\n\t * \n\t * @param key\n\t * @param start\n\t * @param end\n\t * @return\n\t */\n\tpublic Long zRemoveRange(String key, long start, long end) {\n\t\treturn redisTemplate.opsForZSet().removeRange(key, start, end);\n\t}\n\n\t/**\n\t * 根据指定的score值的范围来移除成员\n\t * \n\t * @param key\n\t * @param min\n\t * @param max\n\t * @return\n\t */\n\tpublic Long zRemoveRangeByScore(String key, double min, double max) {\n\t\treturn redisTemplate.opsForZSet().removeRangeByScore(key, min, max);\n\t}\n\n\t/**\n\t * 获取key和otherKey的并集并存储在destKey中\n\t * \n\t * @param key\n\t * @param otherKey\n\t * @param destKey\n\t * @return\n\t */\n\tpublic Long zUnionAndStore(String key, String otherKey, String destKey) {\n\t\treturn redisTemplate.opsForZSet().unionAndStore(key, otherKey, destKey);\n\t}\n\n\t/**\n\t * \n\t * @param key\n\t * @param otherKeys\n\t * @param destKey\n\t * @return\n\t */\n\tpublic Long zUnionAndStore(String key, Collection<String> otherKeys,\n\t\t\tString destKey) {\n\t\treturn redisTemplate.opsForZSet()\n\t\t\t\t.unionAndStore(key, otherKeys, destKey);\n\t}\n\n\t/**\n\t * 交集\n\t * \n\t * @param key\n\t * @param otherKey\n\t * @param destKey\n\t * @return\n\t */\n\tpublic Long zIntersectAndStore(String key, String otherKey,\n\t\t\tString destKey) {\n\t\treturn redisTemplate.opsForZSet().intersectAndStore(key, otherKey,\n\t\t\t\tdestKey);\n\t}\n\n\t/**\n\t * 交集\n\t * \n\t * @param key\n\t * @param otherKeys\n\t * @param destKey\n\t * @return\n\t */\n\tpublic Long zIntersectAndStore(String key, Collection<String> otherKeys,\n\t\t\tString destKey) {\n\t\treturn redisTemplate.opsForZSet().intersectAndStore(key, otherKeys,\n\t\t\t\tdestKey);\n\t}\n\n\t/**\n\t * \n\t * @param key\n\t * @param options\n\t * @return\n\t */\n\tpublic Cursor<TypedTuple<String>> zScan(String key, ScanOptions options) {\n\t\treturn redisTemplate.opsForZSet().scan(key, options);\n\t}\n\t\n\t /**\n     * 获取Redis List 序列化\n     * @param key\n     * @param targetClass\n     * @param <T>\n     * @return\n     */\n    public <T> List<T> getListCache(final String key, Class<T> targetClass) {\n        byte[] result = redisTemplate.execute(new RedisCallback<byte[]>() {\n            @Override\n            public byte[] doInRedis(RedisConnection connection) throws DataAccessException {\n                return connection.get(key.getBytes());\n            }\n        });\n        if (result == null) {\n            return null;\n        }\n        return ProtoStuffSerializerUtil.deserializeList(result, targetClass);\n    }\n\n    /***\n     * 将List 放进缓存里面\n     * @param key\n     * @param objList\n     * @param expireTime\n     * @param <T>\n     * @return\n     */\n    public <T> boolean putListCacheWithExpireTime(String key, List<T> objList, final long expireTime) {\n        final byte[] bkey = key.getBytes();\n        final byte[] bvalue = ProtoStuffSerializerUtil.serializeList(objList);\n        boolean result = redisTemplate.execute(new RedisCallback<Boolean>() {\n            @Override\n            public Boolean doInRedis(RedisConnection connection) throws DataAccessException {\n                connection.setEx(bkey, expireTime, bvalue);\n                return true;\n            }\n        });\n        return result;\n    }\n}\n```\n\n# 用法\n\n最全的Java操作Redis的工具类，封装了对Redis五种基本类型的各种操作，力求符合Redis的原生操作，使用StringRedisTemplate实现！\n\n## keys相关命令\n\n|  NO  | 方法                                                    |  描述                                    |\n|:----:|---------------------------------------------------------|-----------------------------------------|\n|   1  | void delete(String key)                                 | key存在时删除key                         |\n|   2  | void delete(Collection keys)                            | 批量删除key                              |\n|   3  | byte[] dump(String key)                                 | 序列化key，返回被序列化的值               |\n|   4  | Boolean hasKey(String key)                              | 检查key是否存在                          |\n|   5  | Boolean expire(String key, long timeout, TimeUnit unit) | 设置过期时间                             |\n|   6  | Boolean expireAt(String key, Date date)                 | 设置过期时间                             |\n|   7  | Set<String> keys(String pattern)                        | 查找所有符合给定模式(pattern)的key        |\n|   8  | Boolean move(String key, int dbIndex)                   | 将当前数据库的key移动到给定的数据库db当中  |\n|   9  | Boolean persist(String key)                             | 移除key的过期时间，key将持久保持          |\n|  10  | Long getExpire(String key, TimeUnit unit)               | 返回key的剩余的过期时间                   |\n|  11  | Long getExpire(String key)                              | 返回key的剩余的过期时间                   |\n|  12  | String randomKey()                                      | 从当前数据库中随机返回一个key             |\n|  13  | void rename(String oldKey, String newKey)               | 修改key的名称                            |\n|  14  | Boolean renameIfAbsent(String oldKey, String newKey)    | 仅当newkey不存在时，将oldKey改名为 newkey |\n|  15  | DataType type(String key)                               | 返回key所储存的值的类型                   |\n\n> **TimeUnit是时间单位，可选值有：**<br>\n> &emsp;天:TimeUnit.DAYS、小时:TimeUnit.HOURS、分钟:TimeUnit.MINUTES、秒:TimeUnit.SECONDS、毫秒:TimeUnit.MILLISECONDS。\n\n<br>\n\n## String数据类型操作\n\n|  NO  | 方法                                                              | 描述                                 |\n|:----:|-------------------------------------------------------------------|-------------------------------------|\n|   1  | String get(String key)                                            | 获取指定key的值                      |\n|   2  | String getRange(String key, long start, long end)                 | 返回key中字符串值的子字符             |\n|   3  | String getAndSet(String key, String value)                        | 将key的值设为value，并返回key旧值     |\n|   4  | Boolean getBit(String key, long offset)                           | 对key所储存的值，获取指定位置上的bit   |\n|   5  | List multiGet(Collection keys)                                    | 批量获取                             |\n|      |     **添加相关**                                                 |                                      |\n|   6  | void set(String key, String value)                                | 设置指定key的值                       |\n|   7  | boolean setBit(String key, long offset, boolean value)            | 设置指定位置上的ASCII码               |\n|   8  | void setEx(String key,String value,long timeout,TimeUnit unit)    | 将值value关联到key，并设置key过期时间  |\n|   9  | boolean setIfAbsent(String key, String value)                     | 只有在 key 不存在时设置 key 的值       |\n|  10  | void setRange(String key, String value, long offset)              | 用value覆写key的值，从偏移量offset开始 |\n|  11  | void multiSet(Map<String,String> maps)                            | 批量添加                              |\n|  12  | boolean multiSetIfAbsent(Map<String,String> maps)                 | 批量添加，仅当所有key都不存在          |\n|      |      **其他方法**                                                 |                                      |\n|  13  | Integer append(String key, String value)                          | 追加到末尾                            |\n|  14  | Long incrBy(String key, long increment)                           | 增加(自增长), 负数则为自减             |\n|  15  | Double incrByFloat(String key, double increment)                  | 增加(自增长), 负数则为自减             |\n|  16  | Long size(String key)                                             | 获取字符串的长度                      |\n\n> **关于上面xxBit方法的使用：**<br>\n> &emsp;例如字符\'a\'的ASCII码是97，转为二进制是\'01100001\'，setBit方法就是把第offset位置上变成0或者1，true是1，false是0。\n\n<br>\n\n## Hash相关的操作 \n\n|  NO  | 方法                                                           | 描述                                   |\n|:----:|----------------------------------------------------------------|---------------------------------------|\n|   1  | Object hGet(String key, String field)                          | 获取存储在哈希表中指定字段的值           |\n|   2  | Map hGetAll(String key)                                        | 获取所有给定字段的值                    |\n|   3  | List hMultiGet(String key, Collection fields)                  | 获取所有给定字段的值                    |\n|      |    **添加相关**                                               |                                       |\n|   4  | void hPut(String key, String hashKey, String value)            | 添加字段                               |\n|   5  | void hPutAll(String key, Map maps)                             | 添加多个字段                            |\n|   6  | Boolean hPutIfAbsent(String key,String hashKey,String value)   | 仅当hashKey不存在时才设置                |\n|      |     **其他方法**                                              |                                        |\n|   7  | Long hDelete(String key, Object... fields)                     | 删除一个或多个哈希表字段                 |\n|   8  | boolean hExists(String key, String field)                      | 查看哈希表key中指定的字段是否存在         |\n|   9  | Long hIncrBy(String key, Object field, long increment)         | 为哈希表key中指定字段的值增加increment   |\n|  10  | Double hIncrByFloat(String key, Object field, double delta)    | 为哈希表key中指定字段的值增加increment   |\n|  11  | Set hKeys(String key)                                          | 获取所有哈希表中的字段                   |\n|  12  | Long hSize(String key)                                         | 获取哈希表中字段的数量                   |\n|  13  | List hValues(String key)                                       | 获取哈希表中所有值                       |\n|  14  | Cursor hScan(String key, ScanOptions options)                  | 迭代哈希表中的键值对                     |\n|  | **引入序列化依赖** | <dependency>     <groupId>com.dyuproject.protostuff</groupId>     <artifactId>protostuff-core</artifactId>     <version>1.0.8</version> </dependency>  <dependency>     <groupId>com.dyuproject.protostuff</groupId>     <artifactId>protostuff-runtime</artifactId>     <version>1.0.8</version> </dependency> |\n| 15 | getListCache(final String key, Class<T> targetClass) | 获取缓存中的List，targetClass是序列化的类 |\n| 16 | putListCacheWithExpireTime(String key, List<T> objList, final long expireTime) | 把List放到缓存，expireTime是过期策略 |\n\n\n\n<br>\n\n## List相关的操作\n\n|  NO  | 方法                                                     | 描述                                        |\n|:----:|----------------------------------------------------------|---------------------------------------------|\n|   1  | String lIndex(String key, long index)                    | 通过索引获取列表中的元素                      |\n|   2  | List lRange(String key, long start, long end)            | 获取列表指定范围内的元素                      |\n|      |     **添加相关**                                        |                                             |\n|   3  | Long lLeftPush(String key, String value)                 | 存储在list头部                               |\n|   4  | Long lLeftPushAll(String key, String... value)           | 存储在list头部                               |\n|   5  | Long lLeftPushAll(String key, Collection value)          | 存储在list头部                               |\n|   6  | Long lLeftPushIfPresent(String key, String value)        | 当list存在的时候才加入                        |\n|   7  | lLeftPush(String key, String pivot, String value)        | 如果pivot存在,再pivot前面添加                 |\n|      |                                                          |                                             |\n|   8  | Long lRightPush(String key, String value)                | 存储在list尾部                               |\n|   9  | Long lRightPushAll(String key, String... value)          | 存储在list尾部                               |\n|  10  | Long lRightPushAll(String key, Collection value)         | 存储在list尾部                               |\n|  11  | Long lRightPushIfPresent(String key, String value)       | 当list存在的时候才加入                        |\n|  12  | lRightPush(String key, String pivot, String value)       | 在pivot元素的右边添加值                       |\n|      |                                                          |                                              |\n|  13  | void lSet(String key, long index, String value)          | 通过索引设置列表元素的值                       |\n|      |    **删除相关**                                          |                                             |\n|  14  | String lLeftPop(String key)                              | 移出并获取列表的第一个元素                     |\n|  15  | String lBLeftPop(String key,long timeout,TimeUnit unit)  | 移出并获取第一个元素,没有则阻塞直到超时或有为止  |\n|      |                                                          |                                              |\n|  16  | String lRightPop(String key)                             | 移除并获取列表最后一个元素                     |\n|  17  | String lBRightPop(String key,long timeout,TimeUnit unit) | 移出并获取最后个元素,没有则阻塞直到超时或有为止  |\n|  18  | String lRightPopAndLeftPush(String sKey,String dKey)     | 移除最后一个元素并加到另一个列表并返回          |\n|  19  | String lBRightPopAndLeftPush(sKey,dKey,timeout,unit)     | 移除最后个元素并加到另个列表并返回,阻塞超时或有  |\n|      |                                                          |                                              |\n|  20  | Long lRemove(String key, long index, String value)       | 删除集合中值等于value得元素                    |\n|  21  | void lTrim(String key, long start, long end)             | 裁剪list                                     |\n|      |     **其他方法**                                         |                                              |\n|  22  | Long lLen(String key)                                    | 获取列表长度                                  |\n\n<br>\n\n## Set相关的操作\n\n|  NO  | 方法                                                                     | 描述                          |\n|:----:|--------------------------------------------------------------------------|-------------------------------|\n|   1  | Set<String> sMembers(String key)                                         | 获取集合所有元素               |\n|   2  | Long sSize(String key)                                                   | 获取集合大小                   |\n|   3  | Boolean sIsMember(String key, Object value)                              | 判断集合是否包含value          |\n|   4  | String sRandomMember(String key)                                         | 随机获取集合中的一个元素       |\n|   5  | List<String> sRandomMembers(String key, long count)                      | 随机获取集合count个元素        |\n|   6  | Set<String> sDistinctRandomMembers(String key, long count)               | 随机获取count个元素并去除重复的 |\n|   7  | Cursor<String> sScan(String key, ScanOptions options)                    | 使用迭代器获取元素             |\n|      |                                                                          |                               |\n|   8  | Set<String> sIntersect(String key, String otherKey)                      | 获取两个集合的交集             |\n|   9  | Set<String> sIntersect(String key, Collection<String> otherKeys)         | 获取key集合与多个集合的交集     |\n|  10  | Long sIntersectAndStore(String key, String oKey, String dKey)            | key集合与oKey的交集存储到dKey中 |\n|  11  | Long sIntersectAndStore(String key,Collection<String> oKeys,String dKey) | key与多个集合的交集存储到dKey中 |\n|      |                                                                          |                               |\n|  12  | Set<String> sUnion(String key, String otherKeys)                         | 获取两个集合的并集             |\n|  13  | Set<String> sUnion(String key, Collection<String> otherKeys)             | 获取key集合与多个集合的并集     |\n|  14  | Long sUnionAndStore(String key, String otherKey, String destKey)         | key集合与oKey的并集存储到dKey中 |\n|  15  | Long sUnionAndStore(String key,Collection<String> oKeys,String dKey)     | key与多个集合的并集存储到dKey中 |\n|      |                                                                          |                               |\n|  16  | Set<String> sDifference(String key, String otherKey)                     | 获取两个集合的差集             |\n|  17  | Set<String> sDifference(String key, Collection<String> otherKeys)        | 获取key集合与多个集合的差集     |\n|  18  | Long sDifference(String key, String otherKey, String destKey)            | key与oKey集合的差集存储到dKey中 |\n|  19  | Long sDifference(String key,Collection<String> otherKeys,String dKey)    | key与多个集合的差集存储到dKey中 |\n|      |    **添加相关**                                                         |                                |\n|  20  | Long sAdd(String key, String... values)                                  | 添加                           |\n|      |    **删除相关**                                                          |                               |\n|  21  | Long sRemove(String key, Object... values)                               | 移除                           |\n|  22  | String sPop(String key)                                                  | 随机移除一个元素                |\n|  23  | Boolean sMove(String key, String value, String destKey)                  | 将key集合中value移到destKey中   |\n\n<br>\n\n## zset数据类型操作\n\n|  NO  | 方法                                                                       | 描述                             |\n|:----:|----------------------------------------------------------------------------|----------------------------------|\n|   1  | Set<String> zRange(String key, long start, long end)                       | 获取元素,小到大排序,s开始e结束位置 |\n|   2  | Set<TypedTuple<String>> zRangeWithScores(String key, long start, long end) | 获取集合元素, 并且把score值也获取  |\n|   3  | Set<String> zRangeByScore(String key, double min, double max)              | 根据score范围查询元素,从小到大排序 |\n|   4  | Set<TypedTuple<String>> zRangeByScoreWithScores(key,double min,double max) | 根据score范围查询元素,并返回score |\n|   5  | Set<TypedTuple> zRangeByScoreWithScores(key,double min,max,long start,end) | 根据score查询元素,s开始e结束位置   |\n|      |                                                                            |                                  |\n|   6  | Set<String> zReverseRange(String key, long start, long end)                | 获取集合元素, 从大到小排序         |\n|   7  | Set<TypedTuple<String>> zReverseRangeWithScores(key, long start, long end) | 获取元素,从大到小排序,并返回score  |\n|   8  | Set<String> zReverseRangeByScore(String key, double min, double max)       | 根据score范围查询元素,从大到小排序 |\n|   9  | Set<TypedTuple> zReverseRangeByScoreWithScores(key,double min,double max)  | 根据score查询,大到小排序返回score |\n|  10  | Set<String> zReverseRangeByScore(key, double min, max, long start, end)    | 根据score查询,大到小,s开始e结束   |\n|      |                                                                            |                                  |\n|  11  | Long zRank(String key, Object value)                                       | 返回元素在集合的排名,score由小到大 |\n|  12  | Long zReverseRank(String key, Object value)                                | 返回元素在集合的排名,score由大到小 |\n|  13  | Long zCount(String key, double min, double max)                            | 根据score值范围获取集合元素的数量  |\n|  14  | Long zSize(String key)                                                     | 获取集合大小                      |\n|  15  | Long zZCard(String key)                                                    | 获取集合大小                      |\n|  16  | Double zScore(String key, Object value)                                    | 获取集合中value元素的score值      |\n|      |                                                                            |                                  |\n|  17  | Long zUnionAndStore(String key, String otherKey, String destKey)           | 获取key和oKey的并集并存储在dKey中 |\n|  18  | Long zUnionAndStore(String key,Collection<String> otherKeys,String dKey)   | 获取key和多个集合并集并存在dKey中  |\n|      |                                                                            |                                  |\n|  19  | Long zIntersectAndStore(String key, String otherKey, String destKey)       | 获取key和oKey交集并存在destKey中  |\n|  20  | Long zIntersectAndStore(String key,Collection<String> oKeys,String dKey)   | 获取key和多个集合交集并存在dKey中  |\n|      |                                                                            |                                  |\n|  21  | Cursor<TypedTuple<String>> zScan(String key, ScanOptions options)          | 使用迭代器获取                    |\n|      |    **添加相关**                                                            |                                 |\n|  22  | Boolean zAdd(String key, String value, double score)                       | 添加元素,zSet按score由小到大排列  |\n|  23  | Long zAdd(String key, Set<TypedTuple<String>> values)                      | 批量添加,TypedTuple使用见下面介绍 |\n|      |    **删除相关**                                                           |                                  |\n|  24  | Long zRemove(String key, Object... values)                                 | 移除                             |\n|  25  | Double zIncrementScore(String key, String value, double delta)             | 增加元素的score值,并返回增加后的值 |\n|  26  | Long zRemoveRange(String key, long start, long end)                        | 移除指定索引位置的成员            |\n|  27  | Long zRemoveRangeByScore(String key, double min, double max)               | 根据指定的score值的范围来移除成员  |\n\n> **批量添加时`TypedTuple`的使用：**<br>\n> TypedTuple<String> typedTuple = new DefaultTypedTuple<String>(value,score)\n\n<br><br>\n\n\n# 知识补充\n\n## Redis知识补充\n&emsp;Redis 可以存储键与5种不同数据结构类型之间的映射，这5种数据结构类型分别为：String（字符串）、List（列表）、Set（集合）、Hash（散列）和 zSet（有序集合）。\n\n### String（字符串）\n\n**结构存储的值：**<br>\n&emsp;&emsp;可以是字符串、整数或者浮点数。\n\n**结构的读写能力：**<br>\n&emsp;&emsp;对整个字符串或者字符串的其中一部分执行操作，对象和浮点数执行自增(increment)或者自减(decrement)。\n\n### List（列表）\n\n**结构存储的值：**<br>\n&emsp;&emsp;一个链表，链表上的每个节点都包含了一个字符串。\n\n**结构的读写能力：**<br>\n&emsp;&emsp;从链表的两端推入或者弹出元素，根据偏移量(offset)对链表进行修剪(trim)，读取单个或者多个元素，根据值来查找或者移除元素。\n\n### Set（集合）\n\n**结构存储的值：**<br>\n&emsp;&emsp;包含字符串的无序收集器(unOrderedCollection)，并且被包含的每个字符串都是独一无二的、各不相同。\n\n**结构的读写能力：**<br>\n&emsp;&emsp;添加、获取、移除单个元素，检查一个元素是否存在于某个集合中，计算交集、并集、差集，从集合里面随机获取元素。\n\n### Hash（散列）\n\n**结构存储的值：**<br>\n&emsp;&emsp;包含键值对的无序散列表。\n\n**结构的读写能力：**<br>\n&emsp;&emsp;添加、获取、移除单个键值对，获取所有键值对。\n\n### zSet（有序集合）\n\n**结构存储的值：**<br>\n&emsp;&emsp;字符串成员(member)与浮点数分值(score)之间的有序映射，元素的排列顺序由分值(score)的大小决定。\n\n**结构的读写能力：**<br>\n&emsp;&emsp;添加、获取、删除单个元素，根据分值(score)范围(range)或者成员来获取元素。\n\n<br>\n\n## RedisTemplate和StringRedisTemplate\n&emsp;&emsp;二者主要区别是他们使用的序列化类不一样，RedisTemplate使用的是JdkSerializationRedisSerializer， \nStringRedisTemplate使用的是StringRedisSerializer，两者的数据是不共通的。\n\n### 1RedisTemplate：\n&emsp;&emsp;RedisTemplate使用的是JDK的序列化策略，向Redis存入数据会将数据先序列化成字节数组然后在存入Redis数据库，\n这个时候打开Redis查看的时候，你会看到你的数据不是以可读的形式展现的，而是以字节数组显示，类似下面：`\\xAC\\xED\\x00\\x05t\\x05sr\\x00`。 \n\n&emsp;&emsp;所以使用RedisTemplate可以把一个Java对象直接存储在Redis里面，但是存进去的数据是不易直观读的，不通用的，\n建议不要直接存一个Object对象，可以变成Hash来存储，也可以转成json格式的数据来存储，在实际应用中也是很多都采用json格式来存储的。\n\n### 2StringRedisTemplate:\n&emsp;&emsp;StringRedisTemplate默认采用的是String的序列化策略，保存的key和value都是采用此策略序列化保存的，\nStringRedisTemplate是继承RedisTemplate的，这种对redis的操方式更优雅，任何Redis连接工具，都可以读出直观的数据，便于数据的维护。\n\n<br>\n\n## Redis与Spring的集成\n1.集成配置\n```xml\n<bean id="poolConfig" class="redis.clients.jedis.JedisPoolConfig">\n\t<property name="maxIdle" value="300" />\n\t<property name="maxTotal" value="600" />\n\t<property name="maxWaitMillis" value="1000" />\n\t<property name="testOnBorrow" value="true" />\n</bean>\n\n<bean id="jedisConnectionFactory" class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory">\n\t<property name="hostName" value="127.0.0.1" />\n\t<property name="password" value="" />\n\t<property name="port" value="6379" />\n\t<property name="poolConfig" ref="poolConfig" />\n</bean>\n\n<bean id="redisTemplate" class="org.springframework.data.redis.core.StringRedisTemplate">\n\t<property name="connectionFactory" ref="jedisConnectionFactory" />\n</bean>\n\n<!-- RedisUtil注入RedisTemplate -->\n<bean id="redisUtil" class="com.xxx.utils.RedisUtil">\n\t<property name="redisTemplate" ref="redisTemplate" />\n</bean>\n```\n2.使用RedisUtil工具类方法如下：\n```java\n@Autowired\nprivate RedisUtil redisUtil;\n```\n\n## SpringBoot中如何使用\n\nmaven依赖：\n```xml\n        <dependency>\n            <groupId>com.dyuproject.protostuff</groupId>\n            <artifactId>protostuff-core</artifactId>\n            <version>1.0.8</version>\n        </dependency>\n\n        <dependency>\n            <groupId>com.dyuproject.protostuff</groupId>\n            <artifactId>protostuff-runtime</artifactId>\n            <version>1.0.8</version>\n        </dependency>\n\n        <!--springboot中的redis依赖-->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-data-redis</artifactId>\n        </dependency>\n```\n\n修改你的RedisUtil代码：\n```java\n@Component\npublic class RedisUtil {\n    @Autowired\n    private StringRedisTemplate redisTemplate;\n\n    ......\n}\n```\n使用`@Autowired`自动注入redisTemplate。\n\n<br>', 'title': '最全的Java操作Redis的工具类，使用StringRedisTemplate实现，封装了对Redis五种基本类型的各种操作！ ', 'categories': ['[随笔分类]数据库~Redis'], 'enclosure': {'length': 0}, 'link': 'https://www.cnblogs.com/wbyixx/p/12151242.html', 'permalink': 'https://www.cnblogs.com/wbyixx/p/12151242.html', 'postid': '12151242', 'source': {}, 'userid': '-2'}