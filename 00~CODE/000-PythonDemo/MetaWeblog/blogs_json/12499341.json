{'dateCreated': <DateTime '20200315T18:56:00' at 0x1a4f25457c8>, 'description': '原文章：https://wangdoc.com/javascript/index.html\n# GlobalEventHandlers 接口\n\n指定事件的回调函数，推荐使用的方法是元素的`addEventListener`方法。\n\n```javascript\ndiv.addEventListener(\'click\', clickHandler, false);\n```\n\n除了之外，还有一种方法可以直接指定事件的回调函数。\n\n```javascript\ndiv.onclick = clickHandler;\n```\n\n这个接口是由`GlobalEventHandlers`接口提供的。它的优点是使用比较方便，缺点是只能为每个事件指定一个回调函数，并且无法指定事件触发的阶段（捕获阶段还是冒泡阶段）。\n\n`HTMLElement`、`Document`和`Window`都继承了这个接口，也就是说，各种 HTML 元素、`document`对象、`window`对象上面都可以使用`GlobalEventHandlers`接口提供的属性。下面就列出这个接口提供的主要的事件属性。\n\n## GlobalEventHandlers.onabort\n\n某个对象的`abort`事件（停止加载）发生时，就会调用`onabort`属性指定的回调函数。\n\n各种元素的停止加载事件，到底如何触发，目前并没有统一的规定。因此实际上，这个属性现在一般只用在`<img>`元素上面。\n\n```javascript\n// HTML 代码如下\n// <img src="example.jpg" id="img">\nvar img = document.getElementById(\'img\');\nimg.onabort = function () {\n  console.log(\'image load aborted.\');\n}\n```\n\n## GlobalEventHandlers.onerror\n\n`error`事件发生时，就会调用`onerror`属性指定的回调函数。\n\n`error`事件分成两种。\n\n一种是 JavaScript 的运行时错误，这会传到`window`对象，导致`window.onerror()`。\n\n```javascript\nwindow.onerror = function (message, source, lineno, colno, error) {\n  // ...\n}\n```\n\n`window.onerror`的处理函数共接受五个参数，含义如下。\n\n- message：错误信息字符串\n- source：报错脚本的 URL\n- lineno：报错的行号，是一个整数\n- colno：报错的列号，是一个整数\n- error： 错误对象\n\n另一种是资源加载错误，比如`<img>`或`<script>`加载的资源出现加载错误。这时，Error 对象会传到对应的元素，导致该元素的`onerror`属性开始执行。\n\n```javascript\nelement.onerror = function (event) {\n  // ...\n}\n```\n\n注意，一般来说，资源的加载错误不会触发`window.onerror`。\n\n## GlobalEventHandlers.onload、GlobalEventHandlers.onloadstart\n\n元素完成加载时，会触发`load`事件，执行`onload()`。它的典型使用场景是`window`对象和`<img>`元素。对于`window`对象来说，只有页面的所有资源加载完成（包括图片、脚本、样式表、字体等所有外部资源），才会触发`load`事件。\n\n对于`<img>`和`<video>`等元素，加载开始时还会触发`loadstart`事件，导致执行`onloadstart`。\n\n## GlobalEventHandlers.onfocus，GlobalEventHandlers.onblur\n\n当前元素获得焦点时，会触发`element.onfocus`；失去焦点时，会触发`element.onblur`。\n\n```javascript\nelement.onfocus = function () {\n  console.log("onfocus event detected!");\n};\nelement.onblur = function () {\n  console.log("onblur event detected!");\n};\n```\n\n注意，如果不是可以接受用户输入的元素，要触发`onfocus`，该元素必须有`tabindex`属性。\n\n## GlobalEventHandlers.onscroll\n\n页面或元素滚动时，会触发`scroll`事件，导致执行`onscroll()`。\n\n## GlobalEventHandlers.oncontextmenu，GlobalEventHandlers.onshow\n\n用户在页面上按下鼠标的右键，会触发`contextmenu`事件，导致执行`oncontextmenu()`。如果该属性执行后返回`false`，就等于禁止了右键菜单。`document.oncontextmenu`与`window.oncontextmenu`效果一样。\n\n```javascript\ndocument.oncontextmenu = function () {\n  return false;\n};\n```\n\n上面代码中，`oncontextmenu`属性执行后返回`false`，右键菜单就不会出现。\n\n元素的右键菜单显示时，会触发该元素的`onshow`监听函数。\n\n## 其他的事件属性\n\n鼠标的事件属性。\n\n- onclick\n- ondblclick\n- onmousedown\n- onmouseenter\n- onmouseleave\n- onmousemove\n- onmouseout\n- onmouseover\n- onmouseup\n- onwheel\n\n键盘的事件属性。\n\n- onkeydown\n- onkeypress\n- onkeyup\n\n焦点的事件属性。\n\n- onblur\n- onfocus\n\n表单的事件属性。\n\n- oninput\n- onchange\n- onsubmit\n- onreset\n- oninvalid\n- onselect\n\n触摸的事件属性。\n\n- ontouchcancel\n- ontouchend\n- ontouchmove\n- ontouchstart\n\n拖动的事件属性分成两类：一类与被拖动元素相关，另一类与接收被拖动元素的容器元素相关。\n\n被拖动元素的事件属性。\n\n- ondragstart：拖动开始\n- ondrag：拖动过程中，每隔几百毫秒触发一次\n- ondragend：拖动结束\n\n接收被拖动元素的容器元素的事件属性。\n\n- ondragenter：被拖动元素进入容器元素。\n- ondragleave：被拖动元素离开容器元素。\n- ondragover：被拖动元素在容器元素上方，每隔几百毫秒触发一次。\n- ondrop：松开鼠标后，被拖动元素放入容器元素。\n\n`<dialog>`对话框元素的事件属性。\n\n- oncancel\n- onclose', 'title': 'javascript：GlobalEventHandlers 接口', 'categories': ['[随笔分类]FrontEnd~JavaScript'], 'enclosure': {'length': 0}, 'link': 'https://www.cnblogs.com/wbyixx/p/12499341.html', 'permalink': 'https://www.cnblogs.com/wbyixx/p/12499341.html', 'postid': '12499341', 'source': {}, 'userid': '-2'}