{'dateCreated': <DateTime '20191117T06:13:00' at 0x1a4f2a3a588>, 'description': '\n## Spring MVC auto-configuration\nSpring Boot 自动配置好了SpringMVC\n\n以下是SpringBoot对SpringMVC的默认配置:**==（WebMvcAutoConfiguration）==**\n\n- Inclusion of `ContentNegotiatingViewResolver` and `BeanNameViewResolver` beans.\n\n  - 自动配置了ViewResolver（视图解析器：根据方法的返回值得到视图对象（View），视图对象决定如何渲染（转发？重定向？））\n  - ContentNegotiatingViewResolver：组合所有的视图解析器的；\n  - ==如何定制：我们可以自己给容器中添加一个视图解析器；自动的将其组合进来；==\n\n- Support for serving static resources, including support for WebJars (see below).静态资源文件夹路径,webjars\n\n- Static `index.html` support. 静态首页访问\n\n- Custom `Favicon` support (see below).  favicon.ico\n\n- 自动注册了 of `Converter`, `GenericConverter`, `Formatter` beans.\n\n  - Converter：转换器；  public String hello(User user)：类型转换使用Converter\n  - `Formatter`  格式化器；  2017.12.17===Date；\n\n```\n@Bean\n@ConditionalOnProperty(prefix = "spring.mvc", name = "date-format")//在文件中配置日期格式化的规则\npublic Formatter<Date> dateFormatter() {\n\treturn new DateFormatter(this.mvcProperties.getDateFormat());//日期格式化组件\n}\n```\n\n\u200b\t==自己添加的格式化器转换器，我们只需要放在容器中即可==\n\n- Support for `HttpMessageConverters` (see below).\n\n  - HttpMessageConverter：SpringMVC用来转换Http请求和响应的；User---Json；\n\n  - `HttpMessageConverters` 是从容器中确定；获取所有的HttpMessageConverter；\n\n    ==自己给容器中添加HttpMessageConverter，只需要将自己的组件注册容器中（@Bean,@Component）==\n\n    \n\n- Automatic registration of `MessageCodesResolver` (see below).定义错误代码生成规则\n\n- Automatic use of a `ConfigurableWebBindingInitializer` bean (see below).\n\n  ==我们可以配置一个ConfigurableWebBindingInitializer来替换默认的；（添加到容器）==\n\n  ```\n  初始化WebDataBinder；\n  请求数据=====JavaBean；\n  ```\n\n**org.springframework.boot.autoconfigure.web：web的所有自动场景；**\n\nIf you want to keep Spring Boot MVC features, and you just want to add additional [MVC configuration](https://docs.spring.io/spring/docs/4.3.14.RELEASE/spring-framework-reference/htmlsingle#mvc) (interceptors, formatters, view controllers etc.) you can add your own `@Configuration` class of type `WebMvcConfigurerAdapter`, but **without** `@EnableWebMvc`. If you wish to provide custom instances of `RequestMappingHandlerMapping`, `RequestMappingHandlerAdapter` or `ExceptionHandlerExceptionResolver` you can declare a `WebMvcRegistrationsAdapter` instance providing such components.\n\nIf you want to take complete control of Spring MVC, you can add your own `@Configuration` annotated with `@EnableWebMvc`.\n\n## 扩展SpringMVC\n```xml\n    <mvc:view-controller path="/hello" view-name="success"/>\n    <mvc:interceptors>\n        <mvc:interceptor>\n            <mvc:mapping path="/hello"/>\n            <bean></bean>\n        </mvc:interceptor>\n    </mvc:interceptors>\n```\n**==编写一个配置类（@Configuration），是WebMvcConfigurerAdapter类型；不能标注@EnableWebMvc==**;\n\n既保留了所有的自动配置，也能用我们扩展的配置；\n\n```java\n//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能\n@Configuration\npublic class MyMvcConfig extends WebMvcConfigurerAdapter {\n\n    @Override\n    public void addViewControllers(ViewControllerRegistry registry) {\n       // super.addViewControllers(registry);\n        //浏览器发送 /atguigu 请求来到 success\n        registry.addViewController("/atguigu").setViewName("success");\n    }\n}\n```\n原理：\n\u200b1）、WebMvcAutoConfiguration是SpringMVC的自动配置类\n\u200b2）、在做其他自动配置时会导入；@Import(**EnableWebMvcConfiguration**.class)\n```java\n    @Configuration\n\tpublic static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration {\n      private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite();\n\n\t //从容器中获取所有的WebMvcConfigurer\n      @Autowired(required = false)\n      public void setConfigurers(List<WebMvcConfigurer> configurers) {\n          if (!CollectionUtils.isEmpty(configurers)) {\n              this.configurers.addWebMvcConfigurers(configurers);\n            \t//一个参考实现；将所有的WebMvcConfigurer相关配置都来一起调用；  \n            \t@Override\n             // public void addViewControllers(ViewControllerRegistry registry) {\n              //    for (WebMvcConfigurer delegate : this.delegates) {\n               //       delegate.addViewControllers(registry);\n               //   }\n              }\n          }\n\t}\n```\n\n\u200b3）、容器中所有的WebMvcConfigurer都会一起起作用；\n4）、我们的配置类也会被调用；\n效果：SpringMVC的自动配置和我们的扩展配置都会起作用；\n\n## 全面接管SpringMVC\nSpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己配置；所有的SpringMVC的自动配置都失效了\n\n**我们需要在配置类中添加@EnableWebMvc即可；**\n```java\n//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能\n@EnableWebMvc\n@Configuration\npublic class MyMvcConfig extends WebMvcConfigurerAdapter {\n\n    @Override\n    public void addViewControllers(ViewControllerRegistry registry) {\n       // super.addViewControllers(registry);\n        //浏览器发送 /atguigu 请求来到 success\n        registry.addViewController("/atguigu").setViewName("success");\n    }\n}\n```\n原理：\n\n为什么@EnableWebMvc自动配置就失效了；\n\n1）@EnableWebMvc的核心\n```java\n@Import(DelegatingWebMvcConfiguration.class)\npublic @interface EnableWebMvc {\n```\n2）、\n```java\n@Configuration\npublic class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport {\n```\n3)、\n```java\n@Configuration\n@ConditionalOnWebApplication\n@ConditionalOnClass({ Servlet.class, DispatcherServlet.class,\n\t\tWebMvcConfigurerAdapter.class })\n//容器中没有这个组件的时候，这个自动配置类才生效\n@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)\n@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)\n@AutoConfigureAfter({ DispatcherServletAutoConfiguration.class,\n\t\tValidationAutoConfiguration.class })\npublic class WebMvcAutoConfiguration {\n```\n\n4）、@EnableWebMvc将WebMvcConfigurationSupport组件导入进来；\n5）、导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能；', 'title': 'Springboot学习：SpringMVC自动配置', 'categories': ['[随笔分类]Java~SpringBoot'], 'enclosure': {'length': 0}, 'link': 'https://www.cnblogs.com/wbyixx/p/11875140.html', 'permalink': 'https://www.cnblogs.com/wbyixx/p/11875140.html', 'postid': '11875140', 'source': {}, 'userid': '-2'}