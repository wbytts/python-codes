{'dateCreated': <DateTime '20200131T00:19:00' at 0x1a4f2996548>, 'description': '\n- Canny是边缘提取算法，在1986年提出的\n- 是一个很好的边缘检测器\n\n# Canny算法介绍\n![](https://img2018.cnblogs.com/blog/1446249/202001/1446249-20200131001658429-1268583683.png)\n\n非最大信号抑制：\n![](https://img2018.cnblogs.com/blog/1446249/202001/1446249-20200131001731767-1478492054.png)\n\n高低阈值连接：\n![](https://img2018.cnblogs.com/blog/1446249/202001/1446249-20200131001823565-1733190053.png)\n\n# example\n\n```python\nimport cv2 as cv\nimport numpy as np\n\n\n# canny运算步骤：5步\n# 1. 高斯模糊 - GaussianBlur\n# 2. 灰度转换 - cvtColor\n# 3. 计算梯度 - Sobel/Scharr\n# 4. 非极大值抑制\n# 5. 高低阈值输出二值图像\n\n# 非极大值抑制：\n# 算法使用一个3×3邻域作用在幅值阵列M[i,j]的所有点上；\n# 每一个点上，邻域的中心像素M[i,j]与沿着梯度线的两个元素进行比较，\n# 其中梯度线是由邻域的中心点处的扇区值ζ[i,j]给出。\n# 如果在邻域中心点处的幅值M[i,j]不比梯度线方向上的两个相邻点幅值大，则M[i,j]赋值为零，否则维持原值；\n# 此过程可以把M[i,j]宽屋脊带细化成只有一个像素点宽，即保留屋脊的高度值。\n\n# 高低阈值连接\n# T1，T2为阈值，凡是高于T2的都保留，凡是低于T1的都丢弃\n# 从高于T2的像素出发，凡是大于T1而且相互连接的都保留。最终得到一个输出二值图像\n# 推荐高低阈值比值为T2:T1 = 3:1/2:1,其中T2高阈值，T1低阈值\n\n\ndef edge_demo(image):\n    blurred = cv.GaussianBlur(image, (3, 3), 0)\n    gray = cv.cvtColor(blurred, cv.COLOR_BGR2GRAY)\n\n    grad_x = cv.Sobel(gray, cv.CV_16SC1, 1, 0)\n    grad_y = cv.Sobel(gray, cv.CV_16SC1, 0, 1)\n\n    # edge_output = cv.Canny(grad_x, grad_y, 30, 150)\n    edge_output = cv.Canny(gray, 50, 150)\n    cv.imshow("gray", gray)\n    cv.imshow("Canny demo", edge_output)\n\n\ndef main():\n    src = cv.imread("../images/Crystal.jpg")\n    cv.imshow("demo",src)\n\n    edge_demo(src)\n    cv.waitKey(0)  # 等有键输入或者1000ms后自动将窗口消除，0表示只用键输入结束窗口\n    cv.destroyAllWindows()  # 关闭所有窗口\n\n\nif __name__ == \'__main__\':\n    main()\n```', 'title': 'opencv python：Canny边缘提取', 'categories': ['[随笔分类]OpenCV~Python', '[随笔分类]OpenCV'], 'enclosure': {'length': 0}, 'link': 'https://www.cnblogs.com/wbyixx/p/12244484.html', 'permalink': 'https://www.cnblogs.com/wbyixx/p/12244484.html', 'postid': '12244484', 'source': {}, 'userid': '-2'}