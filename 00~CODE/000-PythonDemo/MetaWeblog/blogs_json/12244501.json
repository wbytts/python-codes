{'dateCreated': <DateTime '20200131T00:33:00' at 0x1a4f2994d88>, 'description': '![](https://img2018.cnblogs.com/blog/1446249/202001/1446249-20200131003002937-948067772.png)\n\n# example\n\n```python\nimport cv2 as cv\nimport numpy as np\n\n\ndef edge_demo(image):\n    blurred = cv.GaussianBlur(image, (3, 3), 0)\n    gray = cv.cvtColor(blurred, cv.COLOR_BGR2GRAY)\n\n    grad_x = cv.Sobel(gray, cv.CV_16SC1, 1, 0)\n    grad_y = cv.Sobel(gray, cv.CV_16SC1, 0, 1)\n\n    # edge_output = cv.Canny(grad_x, grad_y, 30, 150)\n    edge_output = cv.Canny(gray, 50, 150)\n    return edge_output\n\n\ndef contours_demo(image):\n    """\n    . 轮廓可以简单认为成将连续的点（连着边界）连在一起的曲线，具有相同 的颜色或者灰度。\n    轮廓在形状分析和物体的检测和识别中很有用。\n    . 为了更加准确，要使用二值化图像。在寻找轮廓之前，要进行阈值化处理或者 Canny 边界检测\n    . 查找轮廓的函数会修改原始图像。如果你在找到轮廓之后还想使用原始图像的话，\n    你应该将原始图像存储到其他变量中.\n    . 在 OpenCV 中，查找轮廓就像在黑色背景中超白色物体。要找的物体应该是白色而背景应该是黑色。\n\n\n    """\n    # dst = cv.GaussianBlur(image, (3, 3), 0)\n    # gray = cv.cvtColor(dst, cv.COLOR_BGR2GRAY)\n    # ret, binary = cv.threshold(gray, 0, 255, cv.THRESH_BINARY | cv.THRESH_OTSU)\n    # cv.imshow("binary image", binary)\n    binary = edge_demo(image)\n    """\n    • 函数 cv2.ﬁndContours() 有三个参数, 第一个是输入图像，第二个是轮廓检索模式，第三个是轮廓近似方法。\n    • 检索模式：\n        • CV_RETR_EXTERNAL - 只提取外层的轮廓  \n        • CV_RETR_LIST - 提取所有轮廓，并且放置在 list 中  \n        • CV_RETR_CCOMP - 提取所有轮廓，并且将其组织为两层的 hierarchy: \n            顶层为连通域的 外围边界，次层为洞的内层边界。  \n        • CV_RETR_TREE - 提取所有轮廓，并且重构嵌套轮廓的全部 hierarchy\n    • 逼近方法 (对所有节点, 不包括使用内部逼近的 CV_RETR_RUNS).  点的存贮情况，是不是都被存贮\n        • CV_CHAIN_CODE - Freeman 链码的输出轮廓. 其它方法输出多边形(定点序列).  \n        • CV_CHAIN_APPROX_NONE - 将所有点由链码形式翻译为点序列形式  \n        • CV_CHAIN_APPROX_SIMPLE - 压缩水平、垂直和对角分割，即函数只保留末端的象素 点;  \n        • CV_CHAIN_APPROX_TC89_L1,  CV_CHAIN_APPROX_TC89_KCOS - 应用 Teh-Chin 链逼近算法.  \n        • CV_LINK_RUNS - 通过连接为 1 的水平碎片使用完全不同的轮廓提取算法。仅有 CV_RETR_LIST 提取模式可以在本方法中应用.  \n    • offset:每一个轮廓点的偏移量. 当轮廓是从图像 ROI 中提取出来的时候，使用偏移量有用，因为可以从整个图像上下文来对轮廓做分析. \n    • 返回值有三个，第一个是图像，第二个是轮廓，第三个是（轮廓的）层析结构。\n        轮廓（第二个返回值）是一个 Python 列表，其中存储这图像中的所有轮廓。\n        每一个轮廓都是一个 Numpy 数组，包含对象边界点（x，y）的坐标。\n    """\n    contours, hierarchy= cv.findContours(binary, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE)\n    for i, contour in enumerate(contours):\n        # 函数 cv2.drawContours() 可以被用来绘制轮廓。它可以根据你提供的边界点绘制任何形状。\n        # 它的第一个参数是原始图像，第二个参数是轮廓，一个 Python 列表。\n        # 第三个参数是轮廓的索引（在绘制独立轮廓是很有用，当设 置为 -1 时绘制所有轮廓）。\n        # 接下来的参数是轮廓的颜色和厚度等。\n        cv.drawContours(image, contours, i, (0, 0, 255), 2)  # 2为像素大小，-1时填充轮廓\n        print(i)\n    cv.imshow("detect contours", image)\n    cv.imwrite("a.jpg", image)\n\n\n\ndef main():\n    src = cv.imread("../images/CrystalLiu2.jpg")\n    cv.imshow("demo", src)\n    contours_demo(src)\n    cv.waitKey(0)  # 等有键输入或者1000ms后自动将窗口消除，0表示只用键输入结束窗口\n    cv.destroyAllWindows()  # 关闭所有窗口\n\n\nif __name__ == \'__main__\':\n    main()\n```', 'title': 'opencv python：轮廓发现', 'categories': ['[随笔分类]OpenCV~Python', '[随笔分类]OpenCV'], 'enclosure': {'length': 0}, 'link': 'https://www.cnblogs.com/wbyixx/p/12244501.html', 'permalink': 'https://www.cnblogs.com/wbyixx/p/12244501.html', 'postid': '12244501', 'source': {}, 'userid': '-2'}