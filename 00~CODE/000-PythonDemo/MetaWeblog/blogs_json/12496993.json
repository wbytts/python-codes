{'dateCreated': <DateTime '20200315T12:55:00' at 0x1a4f2563f48>, 'description': '原文章：https://wangdoc.com/javascript/index.html\n# 属性描述对象\n\n## 概述\n\nJavaScript 提供了一个内部数据结构，用来描述对象的属性，控制它的行为，比如该属性是否可写、可遍历等等。这个内部数据结构称为“属性描述对象”（attributes object）。每个属性都有自己对应的属性描述对象，保存该属性的一些元信息。\n\n下面是属性描述对象的一个例子。\n\n```javascript\n{\n  value: 123,\n  writable: false,\n  enumerable: true,\n  configurable: false,\n  get: undefined,\n  set: undefined\n}\n```\n\n属性描述对象提供6个元属性。\n\n（1）`value`\n\n`value`是该属性的属性值，默认为`undefined`。\n\n（2）`writable`\n\n`writable`是一个布尔值，表示属性值（value）是否可改变（即是否可写），默认为`true`。\n\n（3）`enumerable`\n\n`enumerable`是一个布尔值，表示该属性是否可遍历，默认为`true`。如果设为`false`，会使得某些操作（比如`for...in`循环、`Object.keys()`）跳过该属性。\n\n（4）`configurable`\n\n`configurable`是一个布尔值，表示可配置性，默认为`true`。如果设为`false`，将阻止某些操作改写该属性，比如无法删除该属性，也不得改变该属性的属性描述对象（`value`属性除外）。也就是说，`configurable`属性控制了属性描述对象的可写性。\n\n（5）`get`\n\n`get`是一个函数，表示该属性的取值函数（getter），默认为`undefined`。\n\n（6）`set`\n\n`set`是一个函数，表示该属性的存值函数（setter），默认为`undefined`。\n\n## Object.getOwnPropertyDescriptor()\n\n`Object.getOwnPropertyDescriptor()`方法可以获取属性描述对象。它的第一个参数是目标对象，第二个参数是一个字符串，对应目标对象的某个属性名。\n\n```javascript\nvar obj = { p: \'a\' };\n\nObject.getOwnPropertyDescriptor(obj, \'p\')\n// Object { value: "a",\n//   writable: true,\n//   enumerable: true,\n//   configurable: true\n// }\n```\n\n上面代码中，`Object.getOwnPropertyDescriptor()`方法获取`obj.p`的属性描述对象。\n\n注意，`Object.getOwnPropertyDescriptor()`方法只能用于对象自身的属性，不能用于继承的属性。\n\n```javascript\nvar obj = { p: \'a\' };\n\nObject.getOwnPropertyDescriptor(obj, \'toString\')\n// undefined\n```\n\n上面代码中，`toString`是`obj`对象继承的属性，`Object.getOwnPropertyDescriptor()`无法获取。\n\n## Object.getOwnPropertyNames()\n\n`Object.getOwnPropertyNames`方法返回一个数组，成员是参数对象自身的全部属性的属性名，不管该属性是否可遍历。\n\n```javascript\nvar obj = Object.defineProperties({}, {\n  p1: { value: 1, enumerable: true },\n  p2: { value: 2, enumerable: false }\n});\n\nObject.getOwnPropertyNames(obj)\n// ["p1", "p2"]\n```\n\n上面代码中，`obj.p1`是可遍历的，`obj.p2`是不可遍历的。`Object.getOwnPropertyNames`会将它们都返回。\n\n这跟`Object.keys`的行为不同，`Object.keys`只返回对象自身的可遍历属性的全部属性名。\n\n```javascript\nObject.keys([]) // []\nObject.getOwnPropertyNames([]) // [ \'length\' ]\n\nObject.keys(Object.prototype) // []\nObject.getOwnPropertyNames(Object.prototype)\n// [\'hasOwnProperty\',\n//  \'valueOf\',\n//  \'constructor\',\n//  \'toLocaleString\',\n//  \'isPrototypeOf\',\n//  \'propertyIsEnumerable\',\n//  \'toString\']\n```\n\n上面代码中，数组自身的`length`属性是不可遍历的，`Object.keys`不会返回该属性。第二个例子的`Object.prototype`也是一个对象，所有实例对象都会继承它，它自身的属性都是不可遍历的。\n\n## Object.defineProperty()，Object.defineProperties()\n\n`Object.defineProperty()`方法允许通过属性描述对象，定义或修改一个属性，然后返回修改后的对象，它的用法如下。\n\n```javascript\nObject.defineProperty(object, propertyName, attributesObject)\n```\n\n`Object.defineProperty`方法接受三个参数，依次如下。\n\n- object：属性所在的对象\n- propertyName：字符串，表示属性名\n- attributesObject：属性描述对象\n\n举例来说，定义`obj.p`可以写成下面这样。\n\n```javascript\nvar obj = Object.defineProperty({}, \'p\', {\n  value: 123,\n  writable: false,\n  enumerable: true,\n  configurable: false\n});\n\nobj.p // 123\n\nobj.p = 246;\nobj.p // 123\n```\n\n上面代码中，`Object.defineProperty()`方法定义了`obj.p`属性。由于属性描述对象的`writable`属性为`false`，所以`obj.p`属性不可写。注意，这里的`Object.defineProperty`方法的第一个参数是`{}`（一个新建的空对象），`p`属性直接定义在这个空对象上面，然后返回这个对象，这是`Object.defineProperty()`的常见用法。\n\n如果属性已经存在，`Object.defineProperty()`方法相当于更新该属性的属性描述对象。\n\n如果一次性定义或修改多个属性，可以使用`Object.defineProperties()`方法。\n\n```javascript\nvar obj = Object.defineProperties({}, {\n  p1: { value: 123, enumerable: true },\n  p2: { value: \'abc\', enumerable: true },\n  p3: { get: function () { return this.p1 + this.p2 },\n    enumerable:true,\n    configurable:true\n  }\n});\n\nobj.p1 // 123\nobj.p2 // "abc"\nobj.p3 // "123abc"\n```\n\n上面代码中，`Object.defineProperties()`同时定义了`obj`对象的三个属性。其中，`p3`属性定义了取值函数`get`，即每次读取该属性，都会调用这个取值函数。\n\n注意，一旦定义了取值函数`get`（或存值函数`set`），就不能将`writable`属性设为`true`，或者同时定义`value`属性，否则会报错。\n\n```javascript\nvar obj = {};\n\nObject.defineProperty(obj, \'p\', {\n  value: 123,\n  get: function() { return 456; }\n});\n// TypeError: Invalid property.\n// A property cannot both have accessors and be writable or have a value\n\nObject.defineProperty(obj, \'p\', {\n  writable: true,\n  get: function() { return 456; }\n});\n// TypeError: Invalid property descriptor.\n// Cannot both specify accessors and a value or writable attribute\n```\n\n上面代码中，同时定义了`get`属性和`value`属性，以及将`writable`属性设为`true`，就会报错。\n\n`Object.defineProperty()`和`Object.defineProperties()`参数里面的属性描述对象，`writable`、`configurable`、`enumerable`这三个属性的默认值都为`false`。\n\n```javascript\nvar obj = {};\nObject.defineProperty(obj, \'foo\', {});\nObject.getOwnPropertyDescriptor(obj, \'foo\')\n// {\n//   value: undefined,\n//   writable: false,\n//   enumerable: false,\n//   configurable: false\n// }\n```\n\n上面代码中，定义`obj.foo`时用了一个空的属性描述对象，就可以看到各个元属性的默认值。\n\n## Object.prototype.propertyIsEnumerable()\n\n实例对象的`propertyIsEnumerable()`方法返回一个布尔值，用来判断某个属性是否可遍历。注意，这个方法只能用于判断对象自身的属性，对于继承的属性一律返回`false`。\n\n```javascript\nvar obj = {};\nobj.p = 123;\n\nobj.propertyIsEnumerable(\'p\') // true\nobj.propertyIsEnumerable(\'toString\') // false\n```\n\n上面代码中，`obj.p`是可遍历的，而`obj.toString`是继承的属性。\n\n## 元属性\n\n属性描述对象的各个属性称为“元属性”，因为它们可以看作是控制属性的属性。\n\n### value\n\n`value`属性是目标属性的值。\n\n```javascript\nvar obj = {};\nobj.p = 123;\n\nObject.getOwnPropertyDescriptor(obj, \'p\').value\n// 123\n\nObject.defineProperty(obj, \'p\', { value: 246 });\nobj.p // 246\n```\n\n上面代码是通过`value`属性，读取或改写`obj.p`的例子。\n\n### writable\n\n`writable`属性是一个布尔值，决定了目标属性的值（value）是否可以被改变。\n\n```javascript\nvar obj = {};\n\nObject.defineProperty(obj, \'a\', {\n  value: 37,\n  writable: false\n});\n\nobj.a // 37\nobj.a = 25;\nobj.a // 37\n```\n\n上面代码中，`obj.a`的`writable`属性是`false`。然后，改变`obj.a`的值，不会有任何效果。\n\n注意，正常模式下，对`writable`为`false`的属性赋值不会报错，只会默默失败。但是，严格模式下会报错，即使对`a`属性重新赋予一个同样的值。\n\n```javascript\n\'use strict\';\nvar obj = {};\n\nObject.defineProperty(obj, \'a\', {\n  value: 37,\n  writable: false\n});\n\nobj.a = 37;\n// Uncaught TypeError: Cannot assign to read only property \'a\' of object\n```\n\n上面代码是严格模式，对`obj.a`任何赋值行为都会报错。\n\n如果原型对象的某个属性的`writable`为`false`，那么子对象将无法自定义这个属性。\n\n```javascript\nvar proto = Object.defineProperty({}, \'foo\', {\n  value: \'a\',\n  writable: false\n});\n\nvar obj = Object.create(proto);\n\nobj.foo = \'b\';\nobj.foo // \'a\'\n```\n\n上面代码中，`proto`是原型对象，它的`foo`属性不可写。`obj`对象继承`proto`，也不可以再自定义这个属性了。如果是严格模式，这样做还会抛出一个错误。\n\n但是，有一个规避方法，就是通过覆盖属性描述对象，绕过这个限制。原因是这种情况下，原型链会被完全忽视。\n\n```javascript\nvar proto = Object.defineProperty({}, \'foo\', {\n  value: \'a\',\n  writable: false\n});\n\nvar obj = Object.create(proto);\nObject.defineProperty(obj, \'foo\', {\n  value: \'b\'\n});\n\nobj.foo // "b"\n```\n\n### enumerable\n\n`enumerable`（可遍历性）返回一个布尔值，表示目标属性是否可遍历。\n\nJavaScript 的早期版本，`for...in`循环是基于`in`运算符的。我们知道，`in`运算符不管某个属性是对象自身的还是继承的，都会返回`true`。\n\n```javascript\nvar obj = {};\n\'toString\' in obj // true\n```\n\n上面代码中，`toString`不是`obj`对象自身的属性，但是`in`运算符也返回`true`，这导致了`toString`属性也会被`for...in`循环遍历。\n\n这显然不太合理，后来就引入了“可遍历性”这个概念。只有可遍历的属性，才会被`for...in`循环遍历，同时还规定`toString`这一类实例对象继承的原生属性，都是不可遍历的，这样就保证了`for...in`循环的可用性。\n\n具体来说，如果一个属性的`enumerable`为`false`，下面三个操作不会取到该属性。\n\n- `for..in`循环\n- `Object.keys`方法\n- `JSON.stringify`方法\n\n因此，`enumerable`可以用来设置“秘密”属性。\n\n```javascript\nvar obj = {};\n\nObject.defineProperty(obj, \'x\', {\n  value: 123,\n  enumerable: false\n});\n\nobj.x // 123\n\nfor (var key in obj) {\n  console.log(key);\n}\n// undefined\n\nObject.keys(obj)  // []\nJSON.stringify(obj) // "{}"\n```\n\n上面代码中，`obj.x`属性的`enumerable`为`false`，所以一般的遍历操作都无法获取该属性，使得它有点像“秘密”属性，但不是真正的私有属性，还是可以直接获取它的值。\n\n注意，`for...in`循环包括继承的属性，`Object.keys`方法不包括继承的属性。如果需要获取对象自身的所有属性，不管是否可遍历，可以使用`Object.getOwnPropertyNames`方法。\n\n另外，`JSON.stringify`方法会排除`enumerable`为`false`的属性，有时可以利用这一点。如果对象的 JSON 格式输出要排除某些属性，就可以把这些属性的`enumerable`设为`false`。\n\n### configurable\n\n`configurable`(可配置性）返回一个布尔值，决定了是否可以修改属性描述对象。也就是说，`configurable`为`false`时，`value`、`writable`、`enumerable`和`configurable`都不能被修改了。\n\n```javascript\nvar obj = Object.defineProperty({}, \'p\', {\n  value: 1,\n  writable: false,\n  enumerable: false,\n  configurable: false\n});\n\nObject.defineProperty(obj, \'p\', {value: 2})\n// TypeError: Cannot redefine property: p\n\nObject.defineProperty(obj, \'p\', {writable: true})\n// TypeError: Cannot redefine property: p\n\nObject.defineProperty(obj, \'p\', {enumerable: true})\n// TypeError: Cannot redefine property: p\n\nObject.defineProperty(obj, \'p\', {configurable: true})\n// TypeError: Cannot redefine property: p\n```\n\n上面代码中，`obj.p`的`configurable`为`false`。然后，改动`value`、`writable`、`enumerable`、`configurable`，结果都报错。\n\n注意，`writable`只有在`false`改为`true`会报错，`true`改为`false`是允许的。\n\n```javascript\nvar obj = Object.defineProperty({}, \'p\', {\n  writable: true,\n  configurable: false\n});\n\nObject.defineProperty(obj, \'p\', {writable: false})\n// 修改成功\n```\n\n至于`value`，只要`writable`和`configurable`有一个为`true`，就允许改动。\n\n```javascript\nvar o1 = Object.defineProperty({}, \'p\', {\n  value: 1,\n  writable: true,\n  configurable: false\n});\n\nObject.defineProperty(o1, \'p\', {value: 2})\n// 修改成功\n\nvar o2 = Object.defineProperty({}, \'p\', {\n  value: 1,\n  writable: false,\n  configurable: true\n});\n\nObject.defineProperty(o2, \'p\', {value: 2})\n// 修改成功\n```\n\n另外，`writable`为`false`时，直接目标属性赋值，不报错，但不会成功。\n\n```javascript\nvar obj = Object.defineProperty({}, \'p\', {\n  value: 1,\n  writable: false,\n  configurable: false\n});\n\nobj.p = 2;\nobj.p // 1\n```\n\n上面代码中，`obj.p`的`writable`为`false`，对`obj.p`直接赋值不会生效。如果是严格模式，还会报错。\n\n可配置性决定了目标属性是否可以被删除（delete）。\n\n```javascript\nvar obj = Object.defineProperties({}, {\n  p1: { value: 1, configurable: true },\n  p2: { value: 2, configurable: false }\n});\n\ndelete obj.p1 // true\ndelete obj.p2 // false\n\nobj.p1 // undefined\nobj.p2 // 2\n```\n\n上面代码中，`obj.p1`的`configurable`是`true`，所以可以被删除，`obj.p2`就无法删除。\n\n## 存取器\n\n除了直接定义以外，属性还可以用存取器（accessor）定义。其中，存值函数称为`setter`，使用属性描述对象的`set`属性；取值函数称为`getter`，使用属性描述对象的`get`属性。\n\n一旦对目标属性定义了存取器，那么存取的时候，都将执行对应的函数。利用这个功能，可以实现许多高级特性，比如某个属性禁止赋值。\n\n```javascript\nvar obj = Object.defineProperty({}, \'p\', {\n  get: function () {\n    return \'getter\';\n  },\n  set: function (value) {\n    console.log(\'setter: \' + value);\n  }\n});\n\nobj.p // "getter"\nobj.p = 123 // "setter: 123"\n```\n\n上面代码中，`obj.p`定义了`get`和`set`属性。`obj.p`取值时，就会调用`get`；赋值时，就会调用`set`。\n\nJavaScript 还提供了存取器的另一种写法。\n\n```javascript\nvar obj = {\n  get p() {\n    return \'getter\';\n  },\n  set p(value) {\n    console.log(\'setter: \' + value);\n  }\n};\n```\n\n上面的写法与定义属性描述对象是等价的，而且使用更广泛。\n\n注意，取值函数`get`不能接受参数，存值函数`set`只能接受一个参数（即属性的值）。\n\n存取器往往用于，属性的值依赖对象内部数据的场合。\n\n```javascript\nvar obj ={\n  $n : 5,\n  get next() { return this.$n++ },\n  set next(n) {\n    if (n >= this.$n) this.$n = n;\n    else throw new Error(\'新的值必须大于当前值\');\n  }\n};\n\nobj.next // 5\n\nobj.next = 10;\nobj.next // 10\n\nobj.next = 5;\n// Uncaught Error: 新的值必须大于当前值\n```\n\n上面代码中，`next`属性的存值函数和取值函数，都依赖于内部属性`$n`。\n\n## 对象的拷贝\n\n有时，我们需要将一个对象的所有属性，拷贝到另一个对象，可以用下面的方法实现。\n\n```javascript\nvar extend = function (to, from) {\n  for (var property in from) {\n    to[property] = from[property];\n  }\n\n  return to;\n}\n\nextend({}, {\n  a: 1\n})\n// {a: 1}\n```\n\n上面这个方法的问题在于，如果遇到存取器定义的属性，会只拷贝值。\n\n```javascript\nextend({}, {\n  get a() { return 1 }\n})\n// {a: 1}\n```\n\n为了解决这个问题，我们可以通过`Object.defineProperty`方法来拷贝属性。\n\n```javascript\nvar extend = function (to, from) {\n  for (var property in from) {\n    if (!from.hasOwnProperty(property)) continue;\n    Object.defineProperty(\n      to,\n      property,\n      Object.getOwnPropertyDescriptor(from, property)\n    );\n  }\n\n  return to;\n}\n\nextend({}, { get a(){ return 1 } })\n// { get a(){ return 1 } })\n```\n\n上面代码中，`hasOwnProperty`那一行用来过滤掉继承的属性，否则可能会报错，因为`Object.getOwnPropertyDescriptor`读不到继承属性的属性描述对象。\n\n## 控制对象状态\n\n有时需要冻结对象的读写状态，防止对象被改变。JavaScript 提供了三种冻结方法，最弱的一种是`Object.preventExtensions`，其次是`Object.seal`，最强的是`Object.freeze`。\n\n### Object.preventExtensions()\n\n`Object.preventExtensions`方法可以使得一个对象无法再添加新的属性。\n\n```javascript\nvar obj = new Object();\nObject.preventExtensions(obj);\n\nObject.defineProperty(obj, \'p\', {\n  value: \'hello\'\n});\n// TypeError: Cannot define property:p, object is not extensible.\n\nobj.p = 1;\nobj.p // undefined\n```\n\n上面代码中，`obj`对象经过`Object.preventExtensions`以后，就无法添加新属性了。\n\n### Object.isExtensible()\n\n`Object.isExtensible`方法用于检查一个对象是否使用了`Object.preventExtensions`方法。也就是说，检查是否可以为一个对象添加属性。\n\n```javascript\nvar obj = new Object();\n\nObject.isExtensible(obj) // true\nObject.preventExtensions(obj);\nObject.isExtensible(obj) // false\n```\n\n上面代码中，对`obj`对象使用`Object.preventExtensions`方法以后，再使用`Object.isExtensible`方法，返回`false`，表示已经不能添加新属性了。\n\n### Object.seal()\n\n`Object.seal`方法使得一个对象既无法添加新属性，也无法删除旧属性。\n\n```javascript\nvar obj = { p: \'hello\' };\nObject.seal(obj);\n\ndelete obj.p;\nobj.p // "hello"\n\nobj.x = \'world\';\nobj.x // undefined\n```\n\n上面代码中，`obj`对象执行`Object.seal`方法以后，就无法添加新属性和删除旧属性了。\n\n`Object.seal`实质是把属性描述对象的`configurable`属性设为`false`，因此属性描述对象不再能改变了。\n\n```javascript\nvar obj = {\n  p: \'a\'\n};\n\n// seal方法之前\nObject.getOwnPropertyDescriptor(obj, \'p\')\n// Object {\n//   value: "a",\n//   writable: true,\n//   enumerable: true,\n//   configurable: true\n// }\n\nObject.seal(obj);\n\n// seal方法之后\nObject.getOwnPropertyDescriptor(obj, \'p\')\n// Object {\n//   value: "a",\n//   writable: true,\n//   enumerable: true,\n//   configurable: false\n// }\n\nObject.defineProperty(o, \'p\', {\n  enumerable: false\n})\n// TypeError: Cannot redefine property: p\n```\n\n上面代码中，使用`Object.seal`方法之后，属性描述对象的`configurable`属性就变成了`false`，然后改变`enumerable`属性就会报错。\n\n`Object.seal`只是禁止新增或删除属性，并不影响修改某个属性的值。\n\n```javascript\nvar obj = { p: \'a\' };\nObject.seal(obj);\nobj.p = \'b\';\nobj.p // \'b\'\n```\n\n上面代码中，`Object.seal`方法对`p`属性的`value`无效，是因为此时`p`属性的可写性由`writable`决定。\n\n### Object.isSealed()\n\n`Object.isSealed`方法用于检查一个对象是否使用了`Object.seal`方法。\n\n```javascript\nvar obj = { p: \'a\' };\n\nObject.seal(obj);\nObject.isSealed(obj) // true\n```\n\n这时，`Object.isExtensible`方法也返回`false`。\n\n```javascript\nvar obj = { p: \'a\' };\n\nObject.seal(obj);\nObject.isExtensible(obj) // false\n```\n\n### Object.freeze()\n\n`Object.freeze`方法可以使得一个对象无法添加新属性、无法删除旧属性、也无法改变属性的值，使得这个对象实际上变成了常量。\n\n```javascript\nvar obj = {\n  p: \'hello\'\n};\n\nObject.freeze(obj);\n\nobj.p = \'world\';\nobj.p // "hello"\n\nobj.t = \'hello\';\nobj.t // undefined\n\ndelete obj.p // false\nobj.p // "hello"\n```\n\n上面代码中，对`obj`对象进行`Object.freeze()`以后，修改属性、新增属性、删除属性都无效了。这些操作并不报错，只是默默地失败。如果在严格模式下，则会报错。\n\n### Object.isFrozen()\n\n`Object.isFrozen`方法用于检查一个对象是否使用了`Object.freeze`方法。\n\n```javascript\nvar obj = {\n  p: \'hello\'\n};\n\nObject.freeze(obj);\nObject.isFrozen(obj) // true\n```\n\n使用`Object.freeze`方法以后，`Object.isSealed`将会返回`true`，`Object.isExtensible`返回`false`。\n\n```javascript\nvar obj = {\n  p: \'hello\'\n};\n\nObject.freeze(obj);\n\nObject.isSealed(obj) // true\nObject.isExtensible(obj) // false\n```\n\n`Object.isFrozen`的一个用途是，确认某个对象没有被冻结后，再对它的属性赋值。\n\n```javascript\nvar obj = {\n  p: \'hello\'\n};\n\nObject.freeze(obj);\n\nif (!Object.isFrozen(obj)) {\n  obj.p = \'world\';\n}\n```\n\n上面代码中，确认`obj`没有被冻结后，再对它的属性赋值，就不会报错了。\n\n### 局限性\n\n上面的三个方法锁定对象的可写性有一个漏洞：可以通过改变原型对象，来为对象增加属性。\n\n```javascript\nvar obj = new Object();\nObject.preventExtensions(obj);\n\nvar proto = Object.getPrototypeOf(obj);\nproto.t = \'hello\';\nobj.t\n// hello\n```\n\n上面代码中，对象`obj`本身不能新增属性，但是可以在它的原型对象上新增属性，就依然能够在`obj`上读到。\n\n一种解决方案是，把`obj`的原型也冻结住。\n\n```javascript\nvar obj = new Object();\nObject.preventExtensions(obj);\n\nvar proto = Object.getPrototypeOf(obj);\nObject.preventExtensions(proto);\n\nproto.t = \'hello\';\nobj.t // undefined\n```\n\n另外一个局限是，如果属性值是对象，上面这些方法只能冻结属性指向的对象，而不能冻结对象本身的内容。\n\n```javascript\nvar obj = {\n  foo: 1,\n  bar: [\'a\', \'b\']\n};\nObject.freeze(obj);\n\nobj.bar.push(\'c\');\nobj.bar // ["a", "b", "c"]\n```\n\n上面代码中，`obj.bar`属性指向一个数组，`obj`对象被冻结以后，这个指向无法改变，即无法指向其他值，但是所指向的数组是可以改变的。', 'title': 'javascript：属性描述对象', 'categories': ['[随笔分类]FrontEnd~JavaScript'], 'enclosure': {'length': 0}, 'link': 'https://www.cnblogs.com/wbyixx/p/12496993.html', 'permalink': 'https://www.cnblogs.com/wbyixx/p/12496993.html', 'postid': '12496993', 'source': {}, 'userid': '-2'}