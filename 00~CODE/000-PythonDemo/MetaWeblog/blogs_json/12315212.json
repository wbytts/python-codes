{'dateCreated': <DateTime '20200215T23:17:00' at 0x1a4f257b8c8>, 'description': '![](https://img2018.cnblogs.com/blog/1446249/202002/1446249-20200215230052211-2044781369.png)\n\n```c++\n#include <opencv2/opencv.hpp>\n#include <iostream>\n\nusing namespace cv;\nusing namespace std;\nRNG rng(12345);\n\nint main(int argc, char** argv)\n{\n     Mat src = imread("f:/images/qq/20200215213837.png");\n    //Mat src = imread("f:/images/qq/yezi.png");\n    if (src.empty())\n    {\n        printf("Could not find the image!\\n");\n        return -1;\n    }\n\n    namedWindow("input", WINDOW_AUTOSIZE);\n    imshow("input", src);\n\n    // 做一个高斯模糊，消除一些细微的东西\n    GaussianBlur(src, src, Size(3, 3), 0);\n    GaussianBlur(src, src, Size(3, 3), 0);\n\n    Mat gray, binary;\n    cvtColor(src, gray, COLOR_BGR2GRAY);\n    imshow("gray", gray);\n\n    // 二值化\n    threshold(gray, binary, 0, 255, THRESH_BINARY | THRESH_OTSU);\n    imshow("binary", binary);\n\n    vector<vector<Point>> contours;\n    vector<Vec4i> hierarchy;\n    //findContours(binary, contours, hierarchy, RETR_TREE, CHAIN_APPROX_SIMPLE, Point());\n    // 只绘制最外层的轮廓\n    findContours(binary, contours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE, Point());\n\n    // 一个一个绘制\n    for (size_t t = 0; t < contours.size(); t++) {\n        double area = contourArea(contours[t]);\n        double len = arcLength(contours[t], true);\n        printf("#%d === area: %.2f, length: %.2f\\n", t, area, len);\n        // 可以在这里过滤较小的面积或周长的轮廓, 2改为-1，就是填充这个轮廓\n        drawContours(src, contours, t, Scalar(0, 0, 255), 1, 8);\n        Rect box = boundingRect(contours[t]);\n        rectangle(src, box, Scalar(255, 0, 0), 1, 8);\n        // 最小外接矩形矩形\n        Point2f pts[4];\n        RotatedRect rrt = minAreaRect(contours[t]);\n        rrt.points(pts);\n        for (int i = 0; i < 4; i++) {\n            line(src, pts[i], pts[(i+1)%4], Scalar(0, 255, 255), 1, 8);\n        }\n        // 绘制外接椭圆\n        ellipse(src, rrt, Scalar(255, 255, 0), 1, 8);\n    }\n\n    // -1代表绘制所有\n    //drawContours(src, contours, -1, Scalar(0, 0, 255), 2, 8);\n    imshow("result", src);\n\n    waitKey(0);\n    destroyAllWindows();\n\n    return 0;\n}\n\n\n```\n', 'title': 'opencv：图像轮廓计算', 'categories': ['[随笔分类]OpenCV'], 'enclosure': {'length': 0}, 'link': 'https://www.cnblogs.com/wbyixx/p/12315212.html', 'permalink': 'https://www.cnblogs.com/wbyixx/p/12315212.html', 'postid': '12315212', 'source': {}, 'userid': '-2'}