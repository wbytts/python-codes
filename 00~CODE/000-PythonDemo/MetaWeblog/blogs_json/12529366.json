{'dateCreated': <DateTime '20200320T07:36:00' at 0x1a4f2532948>, 'description': '# 前端代码复杂化带来的问题\n\n在网页开发的早期，js作为一种脚本语言，做一些简单的表单验证或者动画实现等，代码较少\n\n随着ajax异步请求的出现，慢慢形成了前后端的分离\n\n导致客户端要完成的事情越来越多，代码量也与日俱增\n\n为了应付代码量的剧增，我们通常会将代码组织在多个js文件中，进行维护\n\n但是这种方式，仍不能避免一些问题（例如全局变量同名）\n\n# 使用闭包方式解决全局变量同名问题\n\n每个人开发的每个模块的代码，都放到闭包里，闭包返回需要共用的数据，用变量接收\n\n这样只需要保证每个文件的变量名不冲突即可\n\n```js\nlet modelXXX= (function(){\n    ......\n\n    return obj;\n})();\n```\n\n# 模块化规范\n\n## CommonJS\n\n导出：\n```js\nmodule.exports = {\n\t......\n}\n```\n\n导入：\n```js\nlet {a, b, c } = require(\'moduleA\')\n\n// 等价于\nlet moduleA = require(\'moduleA\')\nlet a = moduleA.a;\nlet b = moduleA.b;\nlet c = moduleA.c;\n```\n\n## ES6 module\n\n使用ES6模块的时候，引入到页面时需要修改script的type, \n设置type为module，就可以避免命名冲突的问题\n这样每一个模块都有自己的空间，不能随意访问其他模块的内容\n\n如果要想自己的东西能够被别的地方使用，可以使用 export 导出\n```js\nexport {a, b, c}\n```\n\n别的地方要使用的时候可以导入\n```js\nimport {a, b, c} from \'xxxxx.js\'\n```\n\n导出方式2：在定义变量的同时进行导出\n```js\nexport var num = 10;  \n```\n也可以导出函数、类等\n\n某些情况下，一个模块中包含某个功能，我们并不希望给这个功能命名，而且让导入者可以自己来命名，这时就可以使用 export default，一个模块只能由一个default\n\n这样导入default的东西就不加大括号了，而且可以自己命名\n\n如果一次性要导入的东西太多，可以这么写\n\n```js\nimport * as xxx from \'xxx\'\n```\n\n## 其他\n\nAMD、CMD\n\n# webpack的基本使用\n\n## 什么是webpack\n\n从本质上来讲，webpack是一个现代的JavaScript应用的静态模块打包工具\n\n当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。\n\n## 与grunt/gulp 的区别\n\n- grunt、gult更加强调的是前端流程的自动化，模块化不是核心\n- webpack更加强调模块化开发管理，其他的是它附带的功能\n\n## webpack安装\n\n```\n全局安装：npm install webpack@3.6.0 -g\n\n注：这里使用 3.6.0 版本是因为 vue cli2 依赖该版本\n\nwebpack —version\n\n局部安装： 添加属性 --save-dev\n\n当在package.json中定义了scripts时，如果其中包含了webpack命令，那么会优先使用本地的webpack，而不是全局的webpack\n```\n\n## 使用命令指定打包文件\n\n```\nwebpack main.js bundle.js\n```\n\nwebpack会将main.js打包成bundle.js，在打包main.js是会自动分析有没有其他依赖，然后自动处理这些依赖\n\n## 根据webpack配置文件打包\n\n基本配置，新建webpack.config.js，写入以下配置，然后就可以使用webpack来打包\n```js\nvar path = require(\'path\')\nconst webpack = require(\'webpack\')\n\nmodule.exports = {\n    // 入口\n    entry: \'./src/main.js\',\n    output: { // 出口\n        // path: \'./dist\', // 不能写相对路径，需要动态获取\n        path: path.resolve(__dirname, \'dist\'),\n        filename: \'bytc.js\',\n        publicPath: \'dist/\'\n    }\n}\n```\n\n也可以在package.json添加build脚本：\n![](https://img2020.cnblogs.com/blog/1446249/202003/1446249-20200320140815232-1504034258.png)\n然后使用 npm run build 来进行打包\n\n# 各种各样的loader\n\nwebpack配置文件中添加一个module属性，下面定义rule属性，声明转换的规则\n\n## css\n\n```\nnpm install --save-dev css-loader\nnpm install style-loader --save-dev\n```\n\n```js\n{\n    test: /\\.css$/,\n    // 也可以直接写 use: [\'style-loader\', \'css-loader]\n    use: [\n        { loader: "style-loader" },\n        { loader: "css-loader" }\n    ]\n},\n```\n\n## less\n\n```\nnpm install --save-dev less-loader less\n```\n\n```js\n{\n    test: /\\.less$/,\n    use: [\'style-loader\',\'css-loader\', \'less-loader\']\n},\n```\n\n## sass\n\n```\nnpm install sass-loader node-sass webpack --save-dev\n```\n\n```js\n{\n    test: /\\.scss$/,\n    use: [\'style-loader\', \'css-loader\', \'sass-loader\']\n},\n```\n\n## image\n\n```\nnpm install --save-dev url-loader\nnpm install --save-dev file-loader\n```\n\n```js\n{\n    test: /\\.(png|jpg|gif)$/,\n    use: [\n        {\n            loader: \'url-loader\',\n            options: {\n                // 当图片小于limit时，会被编译成base64字符串形式\n                // 当图片大于limit时，需要使用file-loader模块进行加载\n                // limit默认是 8196\n                limit: 13000,\n                name: \'images/[name]-[hash:8].[ext]\'\n            }\n        }\n    ]\n},\n```\n\n图片转换之后可以指定发布路径，通过module的output的publicPath属性：\n\n```\noutput: {\n    // path: \'./dist\', // 不能写相对路径，需要动态获取\n    path: path.resolve(__dirname, \'dist\'),\n    filename: \'bytc.js\',\n    publicPath: \'dist/\'\n},\n```\n\n![](https://img2020.cnblogs.com/blog/1446249/202003/1446249-20200320141534556-2025751624.png)\n\n\n## es6语法处理\n\n```\nnpm install --save-dev babel-loader@7 babel-core babel-preset-es2015\n```\n\nrule:\n```js\n{\n\t\ttest: /\\.js$/,\n\t\texclude: /(node_modules|bower_components)/,\n\t\tuse: {\n\t\t    loader: \'babel-loader\',\n\t\t    options: {\n\t\t        presets: [\'es2015\']\n\t\t    }\n\t\t}\n}\n```\n\n# 使用vue.js并用webpack打包\n\n我们首先使用npm来安装vue：`npm install vue --save`\n\n我们在入口js脚本里引入vue：\n\n```js\nimport Vue from \'vue\'\n\nnew Vue({\n    el: \'#app\',\n})\n```\n\n其中，在index.html中要定义一个id是app的div和这个Vue实例进行对应\n\n![](https://img2020.cnblogs.com/blog/1446249/202003/1446249-20200320144040487-1156686289.png)\n\n\n然后，使用webpack打包即可\n\n但是，打包之后发现，网页打开报错？\n\n```\n原因是，会生成两种vue代码\n\nruntime-only：代码中，不可以有任何的template\n\nruntime-compile：代码中可以有template，因为有compiler可以用来编译template\n```\n\n如果要使用compile的类型，要在webpack中添加以下配置：\n![](https://img2020.cnblogs.com/blog/1446249/202003/1446249-20200320142856438-1863864636.png)\n\n再次打包即可\n\n# 抽取vue的template\n\n虽然直接引入vue可以进行使用，但是这样的话，会导致入口脚本的Vue实例中会有很多很多代码，index.html的app div也会很复杂\n\n我们想要的是，index.html的结构很简单，入口脚本的结构也很简单\n\n我们可以先定义一个App组件，然后在vue实例中使用template属性中使用这个组件，这时template会替换 el 选项指定的div\n\n然后，将这个App组件抽离出去，放到一个单独的js脚本中，在入口脚本引入这个组件脚本即可\n\n![](https://img2020.cnblogs.com/blog/1446249/202003/1446249-20200320143223586-1397893455.png)\n\n我们可以新建一个文件夹专门存放声明组件的js文件，这样会很方便管理\n\n# 封装 .vue 文件\n\n虽然上面把组件抽离出来，使入口文件和index.html变的简单了，但是抽离出的组件写起来仍然很麻烦\n\n原因是，抽取出去的是js文件，里面要声明一些template的东西很麻烦\n\n这个时候就需要使用vue文件了，.vue文件中可以把template，script、style分开来写\n\n然后像引入js文件一样引入vue文件即可\n\n要使用vue还需要安装vue-loader和vue-template-compiler\n\n```\nnpm install vue-loader vue-template-compiler --save-dev\n```\n\n然后添加webpack规则：\n\n```js\n{\n\t\ttest: /\\.vue$/,\n\t\tuse: [\'vue-loader\']\n}\n```\n\nvue-laoder大于13的版本，使用时还需要配置一个插件\n\n如果不想配置插件，就将版本改成13就可以了  `"vue-loader": "^13.0.0"`', 'title': '从前端模块化 到 webpack 再到使用 vue文件', 'categories': ['[随笔分类]FrontEnd~'], 'enclosure': {'length': 0}, 'link': 'https://www.cnblogs.com/wbyixx/p/12529366.html', 'permalink': 'https://www.cnblogs.com/wbyixx/p/12529366.html', 'postid': '12529366', 'source': {}, 'userid': '-2'}