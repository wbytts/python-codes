{'dateCreated': <DateTime '20200121T17:54:00' at 0x1a4f29ce608>, 'description': '# 概念\n\n一段代码，集中到一起，起一个名字，下一次可以使用这个名字调用这个代码块，就是函数的功能\n\n作用：\n- 方便代码的重用\n- 分解任务，简化程序逻辑\n- 使代码更加模块化\n\n# 函数的分类\n\n- 内建函数\n- 第三方函数\n- 自定义函数\n\n# 函数定义\n\n## 简单定义\n\n```python\ndef 函数名():\n    函数体代码\n```\n\n```python\n函数名()  # 函数调用\n```\n\n# 参数\n\n## 固定个数的参数\n\n```python\ndef xxx(参数1, 参数2, ...):\n    ......\n    # 在函数体，直接以变量的方式使用传过来的参数\n```\n\n这种方式，调用的时候，形参与实参一一对应\n\n## 关键字参数\n\n固定个数的参数不止可以按位置一一对应地去调用传参，也可以按参数名进行指定，这种方式不必按照原来的顺序\n\n```python\ndef xxx(name1, name2, ...):\n    ......\n```\n\n调用：\n```python\nxxx(name2=..., name1=...)\n```\n\n## 不定长参数\n\n将除了按位置匹配以外的参数，收集到一起\n\n### 收集为元组\n\n```python\ndef xx(...., *args):\n    .....\n```\n\n函数调用时，多余的参数，会组成元组赋值给args\n\n### 收集为字典\n\n```python\ndef xx(...., **kwargs):\n    ......\n```\n\n可以将多余的关键字参数收集为字典，函数内可以直接当做字典使用\n\n### 参数的拆包和装包\n\n装包：把传递的参数，包装起来\n拆包：把包装起来的参数，再次拆分为单独的个体\n\n### 缺省参数\n\n有些参数可以设置默认值，也就是调用的时候如果不传值，则会使用设置的默认值\n\n注意：默认值参数需要写在最后面\n\n# 返回值\n\n函数可以返回任意对象\n\n`return xxx`\n\n注意：\n- return后的代码不会被执行\n- return只会被执行一次\n\n# 函数描述\n\n在函数体的最前面，添加三引号的注释\n\n可以使用 `help(函数名)` 查看注释的内容 \n\n# 偏函数\n\n当我们写一个参数比较多的函数时，如果有些函数，大部分场景下都是某一个默认值，那么为了简化使用，就可以创建一个新函数，指定我们要使用的函数的某个参数，为某个固定的值，这个新的函数就是 “偏函数”\n\n可以自己手动创建，但是python也为我们提供了专门的工具：\n```python\nimport functools\n\nfunctools.partial(函数名, 特定参数=偏爱值) # 返回生成好的偏函数\n```\n\n# 高阶函数\n\n当一个函数A的某个参数是另一个函数时，则把这个函数A称为是高阶函数\n\n# 返回函数\n\n函数也可以作为返回值。。。\n\n# 匿名函数\n\n匿名函数也称为 lambda函数，也就是没有名字的函数\n\n语法：`lambda 参数表: 返回值`\n\n# 闭包的概念\n\n在函数嵌套的前提下，内层函数引用了外层函数的变量（包括参数）\n\n外层函数，又把内存函数当做返回值进行返回\n\n这个内层函数+所引用的外层变量，称为闭包\n\n常用场景：外层函数，根据不同的参数，来生成不同作用功能的函数\n\n注意：\n- 闭包中，如果要修改引用的外部变量\n  - 需要使用 `nolocal 变量名` 声明\n  - 否则当做闭包内，新定义的变量\n- 当闭包内引用了一个后期会发生变化的变量时，一定要注意\n  - 当函数被调用的时候，才会真正确定所使用的的值，在此之前，都是以普通的变量标识而存在\n\n# 装饰器\n\n## 装饰器的概念\n\n在函数名以及函数体不改变的前提下，给函数附件一些额外的代码\n\n```python\ndef zsq(func):\n    def inner():\n        ...\n        func()\n        ...\n    return inner\n\n@zsq\ndef xxx():\n    ......\n    \n# @zsq 就相当于 xxx = xsq(xxx)\n```\n\n## 装饰器的叠加\n\n从上往下装饰，从下往上执行\n\n## 对有参函数进行装饰\n\n无论什么场景，保证函数调用参数一致\n\n为了通用，可以使用不定长参数，结合拆包操作进行处理\n\n```python\ndef zsq(func):\n    def inner(*args, **kwargs):\n        ...\n        func(*args, **kwargs)\n        ...\n    return inner\n```\n\n\n\n## 对有返回值的函数进行装饰\n\n```python\ndef zsq(func):\n    def inner(*args, **kwargs):\n        ...\n        ret = func(*args, **kwargs)\n        ...\n        return ret\n\n    return inner\n```\n\n## 带有参数的装饰器\n\n通过 `@装饰器(参数)` 的方式，调用这个函数，并传递参数；并把返回值，再次当做装饰器使用\n\n先计算 @ 后面的内容，把这个内容当做装饰器\n\n# 生成器\n\n是一个特殊的迭代器（迭代器的抽象层级更高）\n\n所以，拥有迭代器的特性：\n\n- 惰性计算数据，节省内存\n- 能够记录状态，并通过next()函数，访问下一个状态\n- 具备可迭代特性\n\n但是，如果自己打造一个迭代器，比较复杂\n\n## 生成器创建方式\n\n- 生成器表达式：把列表推导式的 `[]`改为 `()`\n- 生成器函数：使用 yield 语句，函数的执行结果就是一个生成器\n\n## 产生数据的方式\n\n生成器具备可迭代特性\n\nnext() 函数 等价于  `生成器.__next__()`\n\nfor in\n\n## send 方法\n\nsend方法有一个参数，指的是上一次被挂起的yield语句的返回值\n\n相比于 `__next__()`，可以额外的给yield语句传值\n\n注意第一次调用\n\n## 关闭生成器\n\n`g.close()`\n\n关闭后如果继续调用，会抛出`StopIteration`异常提示\n\n## 注意\n\n如果遇到return，生成器会直接终止\n\n生成器只会遍历一次\n\n# 递归\n\n在函数A内部，直接或者间接调用函数A\n\n# 函数作用域\n\n变量的作用域：\n\n- 变量的作用范围：可操作范围\n- Python是静态作用域，也就是说在Python中，变量的作用域源于它在代码中的位置；在不同的位置，可能有不同的命名空间\n- 命名空间：\n  - 是作用域的体现形式\n  - 不同的具体的操作范围\n- Python-LEGB\n  - L：Local：\n    - 函数内的命名空间，\n    - 作用范围：当前整个函数体范围\n  - E：Enclosing function locals：\n    - 外部嵌套函数的命名空间\n    - 作用范围：闭包函数\n  - G：Global\n    - 全局命名空间\n    - 作用范围：当前模块（文件）\n  - B：Builtin\n    - 内建模块命名空间\n    - 作用范围：所有模块（文件）\n  - 注意：\n    - Python中没有块级作用域\n    - 块级作用域：代码块中，比如if、while、for后面的代码块\n  - LEGB规则：按照 L、E、G、B的顺序进行查找\n\n\n\n常见的变量类型：\n\n- 局部变量\n  - 在一个函数内部定义的变量\n  - 作用域为函数内部\n  - 查看局部变量  locals()\n- 全局变量\n  - 在函数外部，文件最外层定义的变量\n  - 作用域为整个文件内部\n  - 查看全局变量  globals()\n- 注意点\n  - 访问原则：从内到外\n  - 结构规范：\n    - 全局变量\n    - 函数定义：使用、修改\n    - 后续代码\n  - 全局变量和局部变量重名\n    - 获取：就近原则\n    - 修改：global声明\n  - 命名', 'title': 'Python：函数基础', 'categories': ['[随笔分类]Python~语法'], 'enclosure': {'length': 0}, 'link': 'https://www.cnblogs.com/wbyixx/p/12222657.html', 'permalink': 'https://www.cnblogs.com/wbyixx/p/12222657.html', 'postid': '12222657', 'source': {}, 'userid': '-2'}