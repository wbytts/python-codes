{'dateCreated': <DateTime '20191205T11:07:00' at 0x1a4f2a21888>, 'description': '转载：\n原文链接：https://blog.csdn.net/qq906627950/article/details/81324825\n\n# 1、运行时数据区\n* JVM所管理的内存包括以下几个运行时数据区域，如图所示\n![](https://img2018.cnblogs.com/blog/1446249/201912/1446249-20191205110440468-1848785183.png)\n\n* 方法区和堆为线程共享区，虚拟机栈、本地方法栈及程序计数器为线程独占区。\n\n## 程序计数器\n\n* 程序计数器是一块较小的空间，它可以看作是当前线程所执行的字节码的行号指示器。\n![](https://img2018.cnblogs.com/blog/1446249/201912/1446249-20191205110448830-139007010.png)\n\n* 如果线程执行的是java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址（可以理解为上图所示的行号），如果正在执行的是native方法，这个计数器的值为undefined。\n\n* JVM的多线程是通过线程轮流切换并分配CPU执行时间片的方式来实现的，任何一个时刻，一个CPU都只会执行一条线程中的指令。为了保证线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程间的程序计数器独立存储，互不影响。\n\n* 此区域是唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError情况的区域，因为程序计数器是由虚拟机内部维护的，不需要开发者进行操作。\n\n## 虚拟机栈\n\n* 每个线程有一个私有的栈，随着线程的创建而创建，生命周期与线程相同。\n\n* 虚拟机栈里面存着的是一种叫“栈帧”的东西，每个方法会创建一个栈帧，栈帧中存放了局部变量表、操作数栈、动态链接、方法出口等信息。\n  * 局部变量表存放了编译期可知的各种基本数据类型和对象引用类型。通常我们所说的“栈内存”指的就是局部变量表这一部分。\n  * ![](https://img2018.cnblogs.com/blog/1446249/201912/1446249-20191205110459124-1505118111.png)\n  * 64位的long和double类型的数据会占用2个局部变量空间，其余的数据类型只占用1个。\n  * 局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧分配多少内存是固定的，运行期间不会改变局部变量表的大小。\n\n* 方法的调用到执行完毕，对应的就是栈帧的入栈和出栈的过程。\n\n* 栈的大小可以固定也可以动态扩展。\n\n* 在固定大小的情况下，当栈调用深度大于JVM所允许的范围，会抛出StackOverflowError异常。\n\n* 在动态扩展的情况下，若扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。\n\n* 栈内存溢出模拟\n```\n  public class MainTest {\n\n      public static void main(String[] args){\n      \tnew MainTest().test();\n      }\n\n      private void test() {\n      \tSystem.out.println("run...");\n      \ttest();\n      }\n  }\n```\n  * 报错如下\n  * ```\n\tException in thread "main" java.lang.StackOverflowError\n\t\tat sun.nio.cs.UTF_8$Encoder.encodeLoop(UTF_8.java:691)\n\t\tat java.nio.charset.CharsetEncoder.encode(CharsetEncoder.java:579)\n\t```\n\n* 图例：\n* ![](https://img2018.cnblogs.com/blog/1446249/201912/1446249-20191205110528581-700256035.png)\n\n\n\n## 本地方法栈\n\n和虚拟机栈类似，两者的区别就是虚拟机栈是为虚拟机执行java方法服务，本地方法栈为虚拟机执行native方法服务 。\n\nHotSpot虚拟机不区分虚拟机栈和本地方法栈，两者是一块的。\n\n与虚拟机栈一样，本地方法栈也会抛StackOverflowError和OutOfMemoryError异常。\n\n## 堆\n\nJVM管理的最大的一块内存区域，存放着对象的实例，是线程共享区。\n\n堆是垃圾收集器管理的主要区域，因此也被称为“GC堆”\n\nJAVA堆的分类：\n* 从内存回收的角度上看，可分为新生代（Eden空间，From Survivor空间、To Survivor空间）及老年代（Tenured Gen）\n* 从内存分配的角度上看，为了解决分配内存时的线程安全性问题，线程共享的JAVA堆中可能划分出多个线程私有的分配缓冲区（TLAB）\n\nJAVA堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。\n\n可通过参数 -Xmx -Xms 来指定运行时堆内存的大小，堆内存空间不足也会抛OutOfMemoryError异常\n\n## 方法区\n\n方法区也是线程共享区，用于存储【虚拟机加载的类信息（类的版本、字段、方法、接口），常量，静态变量，即时编译器编译后的代码等数据】\n\n方法区逻辑上属于堆的一部分，但是为了与堆进行区分，通常又叫“非堆”。\n\nHotSpot虚拟机使用永久代来实现方法区，使得HotSpot虚拟机的垃圾收集器可以像管理堆内存一样来管理这部分内存，能省去专门为方法区编写内存管理代码工作。所以开发者喜欢将方法区称为永久代，本质上两者并不等价，对于其他虚拟机来说不存在永久代的概念。\n\n方法区可选择不实现垃圾收集，一般来说，这个区域对内存回收的条件较为苛刻，但是这部分区域的回收确实是必要的。\n\n当方法区无法满足内存分配需求时，将会抛OutOfMemoryError异常\n\n运行时常量池\n* 运行时常量池是方法区的一部分。\n* class文件除了有类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后加入方法区的运行时常量池中存放。\n* 运行时常量池相于class文件中的常量池所不同的是其具备了动态性。class文件中常量池中的常量在编译期间就已经定义好了，而运行时常量池在程序运行期间也可以将常量放入该常量池中，最常见的做法就是调用String类的intern()方法。\n\n# 2、对象的创建\n一个对象的创建主要包括了一下几大流程\n![](https://img2018.cnblogs.com/blog/1446249/201912/1446249-20191205110543682-1103118785.png)\n\n在JVM在堆中为对象分配内存阶段，通常有以下两种分配方式，虚拟机选择哪种分配方式是由JAVA堆是否规整决定的，而JAVA堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。\n* 1）指针碰撞：要求堆中内存绝对规整，所有用过的内存都放一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅只是将该指针向空闲空间那边挪动一段与对象大小相等的距离。\n* ![](https://raw.githubusercontent.com/wbytts/images/master/2019/1020191205111541.png)\n* 2）空闲列表：针对的是堆中内存不规整的情况，虚拟机维护着一个列表，记录哪些内存块是可用的，在分配时从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。\n\n在为对象分配内存时，还需要考虑的一点就是线程安全性问题。可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。针对这种问题，有以下两种解决方案。\n* 1）对分配内存空间的动作进行同步处理，保证更新操作的原子性（采用CAS + 失败重试机制保障原原子性），但效率较低。\n* 2）使用本地线程分配缓冲（TLAB），哪个线程需要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并需要分配新的TLAB时，才需要同步锁定（可通过-XX:+/-UseTLAB参数来设定虚拟机启用TLAB）。\n* ![](https://img2018.cnblogs.com/blog/1446249/201912/1446249-20191205110559993-890082245.png)\n\n\n# 3、对象的内存布局\n在HotSpot虚拟机中，对象在内存中存储的布局可分为3块区域：对象头、实例数据和对齐填充。\n\n* 1）对象头，由 Mark Word 和类型指针所组成。\n\nMark Word，用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有锁、偏向线程ID、偏向时间戳等。\n  * Mark Word在32位的JVM中对应的长度是32bit，在64位的JVM中长度是64bit。\n  * 由于对象需要存储的运行数据很多，其实已经超出了32位和64位的限制，为了在极小的空间内存储尽量更多的信息，Mark Word 会根据对象状态的不同来存储不同的信息。如在32位的HotSpot虚拟机中，如对象处于未被锁定的状态，那么 Mark Word 将使用25bit用于存储对象的哈希码，4bit用于存储对象分代年龄，2bit用于存储锁标志位，1bit固定为0，其他状态如下表所示：\n  * ![](https://img2018.cnblogs.com/blog/1446249/201912/1446249-20191205110609130-1801092979.png)\n\n\n类型指针，虚拟机通过这个指针来确定对象是哪个类的实例，该指针指向对象的类元数据。（由于查找对象的元数据信息并不一定要经过对象本身，所以并不是所有的虚拟机实现都必须在对象数据上保留类型指针）\n\n如果对象是一个JAVA数组，那么在对象头中还必须有一块用于记录数组长度的数据，因为普通对象的大小可通过元数据信息来获取，而数组不行。\n\n* 2）实例数据，对象真正存储的有效信息，也就是在代码中所定义+的各种类型的字段内容。\n  * 无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。\n  * 存储顺序收虚拟机分配策略参数（FieldsAllocationStyle）和字段在java源码中定义顺序的影响。\n  * HotSpot虚拟机默认的分配策略为longs/doubles、ints、shorts/chars、bytes/booleans、oops(Ordinary Object Pointers)，相同带宽的字段总是被分配到一起，在此之后，父类中定义的变量会出现在子类之前。\n  * 如果CompactFields参数的值为true（默认为true），那么子类中较窄的变量也可能会插入到父类变量的空隙中。\n\n* 3）对齐填充，无特殊含义，仅仅起到占位符的作用。HotSpot虚拟机要求起始地址必须是8字节的整数倍，因此当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。\n', 'title': 'JAVA的内存结构', 'categories': ['[随笔分类]Java', '[随笔分类]Java~JVM'], 'enclosure': {'length': 0}, 'link': 'https://www.cnblogs.com/wbyixx/p/11987978.html', 'permalink': 'https://www.cnblogs.com/wbyixx/p/11987978.html', 'postid': '11987978', 'source': {}, 'userid': '-2'}