{'dateCreated': <DateTime '20191111T03:04:00' at 0x1a4f2a49148>, 'description': '# springboot依赖的父项目\n\n我们在创建springboot项目的时候，设置了一个父项目：\n![](https://img2018.cnblogs.com/blog/1446249/201911/1446249-20191111030041148-2030624047.png)\n\n这个项目可以点进去，可以发现它依赖于另一个父项目\n![](https://img2018.cnblogs.com/blog/1446249/201911/1446249-20191111030105144-291513918.png)\n\n再次点进去，发现没有依赖父项目了\n观察这个项目的pom文件，发现它定义了好多版本号\n![](https://img2018.cnblogs.com/blog/1446249/201911/1446249-20191111030013007-1366702193.png)\n\n其实导入的这个父项目主要功能是进行版本的管理，对于常用的jar包使用的时候可以不指定版本号，而让springboot的父项目自动管理这些依赖的版本\nSpring Boot的版本仲裁中心；\n以后我们导入依赖默认是不需要写版本；（没有在dependencies里面管理的依赖自然需要声明版本号）\n\n# springboot 启动器\n\nSpring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。\n我们需要用什么功能就导入什么场景的启动器\n比如，我们要做web功能，就可以导入web相关的启动器：\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n```\nspring-boot-starter：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件；\nSpring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器\n\n\n# Springboot 主程序类分析\n主程序类、主入口类：\n```java\n/**\n *  @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用\n */\n@SpringBootApplication\npublic class HelloWorldMainApplication {\n\n    public static void main(String[] args) {\n\n        // Spring应用启动起来\n        SpringApplication.run(HelloWorldMainApplication.class,args);\n    }\n}\n```\n@**SpringBootApplication**:    Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用；\n\n点进去查看这个注解的源码：\n```java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@SpringBootConfiguration\n@EnableAutoConfiguration\n@ComponentScan(excludeFilters = {\n      @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),\n      @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })\npublic @interface SpringBootApplication {\n```\n* @**SpringBootConfiguration**:Spring Boot的配置类；标注在某个类上，表示这是一个Spring Boot的配置类；\n    * @**Configuration**:配置类上来标注这个注解；\n        * 配置类 -----  配置文件；*配置类也是容器中的一个组件*；@Component\n\n* @**EnableAutoConfiguration**：开启自动配置功能；\n    * 以前我们需要配置的东西，Spring Boot帮我们自动配置；@**EnableAutoConfiguration**告诉SpringBoot开启自动配置功能；这样自动配置才能生效；\n* @**EnableAutoConfiguration**点进去看一下内容：\n```java\n@AutoConfigurationPackage\n@Import(EnableAutoConfigurationImportSelector.class)\npublic @interface EnableAutoConfiguration {\n```\n* @**AutoConfigurationPackage**：自动配置包（点进去）\n    * @**Import**(AutoConfigurationPackages.Registrar.class)：\n        * Spring的底层注解@Import，给容器中导入一个组件；导入的组件由AutoConfigurationPackages.Registrar.class；\n<span style="color:red;">将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器；</span>\n\n* @**Import**(EnableAutoConfigurationImportSelector.class)；\n* 给容器中导入组件？\n**EnableAutoConfigurationImportSelector**：导入哪些组件的选择器；\n将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中；\n会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件；\n打断点调试内部代码：\n![](https://img2018.cnblogs.com/blog/1446249/201911/1446249-20191116112733961-1677024086.png)\n有了自动配置类，免去了我们手动编写配置注入功能组件等的工作；\n\nSpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class,classLoader)；\n==Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；==以前我们需要自己配置的东西，自动配置类都帮我们；\n\nJ2EE的整体整合解决方案和自动配置都在spring-boot-autoconfigure-1.5.9.RELEASE.jar；', 'title': 'Springboot学习：底层依赖与自动配置的原理', 'categories': ['[随笔分类]Java~SpringBoot'], 'enclosure': {'length': 0}, 'link': 'https://www.cnblogs.com/wbyixx/p/11832617.html', 'permalink': 'https://www.cnblogs.com/wbyixx/p/11832617.html', 'postid': '11832617', 'source': {}, 'userid': '-2'}