{'dateCreated': <DateTime '20200315T12:18:00' at 0x1a4f2567ac8>, 'description': '原文章：https://wangdoc.com/javascript/index.html\n# 错误处理机制\n\n## Error 实例对象\n\nJavaScript 解析或运行时，一旦发生错误，引擎就会抛出一个错误对象。JavaScript 原生提供`Error`构造函数，所有抛出的错误都是这个构造函数的实例。\n\n```javascript\nvar err = new Error(\'出错了\');\nerr.message // "出错了"\n```\n\n上面代码中，我们调用`Error`构造函数，生成一个实例对象`err`。`Error`构造函数接受一个参数，表示错误提示，可以从实例的`message`属性读到这个参数。抛出`Error`实例对象以后，整个程序就中断在发生错误的地方，不再往下执行。\n\nJavaScript 语言标准只提到，`Error`实例对象必须有`message`属性，表示出错时的提示信息，没有提到其他属性。大多数 JavaScript 引擎，对`Error`实例还提供`name`和`stack`属性，分别表示错误的名称和错误的堆栈，但它们是非标准的，不是每种实现都有。\n\n- **message**：错误提示信息\n- **name**：错误名称（非标准属性）\n- **stack**：错误的堆栈（非标准属性）\n\n使用`name`和`message`这两个属性，可以对发生什么错误有一个大概的了解。\n\n```javascript\nif (error.name) {\n  console.log(error.name + \': \' + error.message);\n}\n```\n\n`stack`属性用来查看错误发生时的堆栈。\n\n```javascript\nfunction throwit() {\n  throw new Error(\'\');\n}\n\nfunction catchit() {\n  try {\n    throwit();\n  } catch(e) {\n    console.log(e.stack); // print stack trace\n  }\n}\n\ncatchit()\n// Error\n//    at throwit (~/examples/throwcatch.js:9:11)\n//    at catchit (~/examples/throwcatch.js:3:9)\n//    at repl:1:5\n```\n\n上面代码中，错误堆栈的最内层是`throwit`函数，然后是`catchit`函数，最后是函数的运行环境。\n\n## 原生错误类型\n\n`Error`实例对象是最一般的错误类型，在它的基础上，JavaScript 还定义了其他6种错误对象。也就是说，存在`Error`的6个派生对象。\n\n### SyntaxError 对象\n\n`SyntaxError`对象是解析代码时发生的语法错误。\n\n```javascript\n// 变量名错误\nvar 1a;\n// Uncaught SyntaxError: Invalid or unexpected token\n\n// 缺少括号\nconsole.log \'hello\');\n// Uncaught SyntaxError: Unexpected string\n```\n\n上面代码的错误，都是在语法解析阶段就可以发现，所以会抛出`SyntaxError`。第一个错误提示是“token 非法”，第二个错误提示是“字符串不符合要求”。\n\n### ReferenceError 对象\n\n`ReferenceError`对象是引用一个不存在的变量时发生的错误。\n\n```javascript\n// 使用一个不存在的变量\nunknownVariable\n// Uncaught ReferenceError: unknownVariable is not defined\n```\n\n另一种触发场景是，将一个值分配给无法分配的对象，比如对函数的运行结果赋值。\n\n```javascript\n// 等号左侧不是变量\nconsole.log() = 1\n// Uncaught ReferenceError: Invalid left-hand side in assignment\n```\n\n上面代码对函数`console.log`的运行结果赋值，结果引发了`ReferenceError`错误。\n\n### RangeError 对象\n\n`RangeError`对象是一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是`Number`对象的方法参数超出范围，以及函数堆栈超过最大值。\n\n```javascript\n// 数组长度不得为负数\nnew Array(-1)\n// Uncaught RangeError: Invalid array length\n```\n\n### TypeError 对象\n\n`TypeError`对象是变量或参数不是预期类型时发生的错误。比如，对字符串、布尔值、数值等原始类型的值使用`new`命令，就会抛出这种错误，因为`new`命令的参数应该是一个构造函数。\n\n```javascript\nnew 123\n// Uncaught TypeError: number is not a func\n\nvar obj = {};\nobj.unknownMethod()\n// Uncaught TypeError: obj.unknownMethod is not a function\n```\n\n上面代码的第二种情况，调用对象不存在的方法，也会抛出`TypeError`错误，因为`obj.unknownMethod`的值是`undefined`，而不是一个函数。\n\n### URIError 对象\n\n`URIError`对象是 URI 相关函数的参数不正确时抛出的错误，主要涉及`encodeURI()`、`decodeURI()`、`encodeURIComponent()`、`decodeURIComponent()`、`escape()`和`unescape()`这六个函数。\n\n```javascript\ndecodeURI(\'%2\')\n// URIError: URI malformed\n```\n\n### EvalError 对象\n\n`eval`函数没有被正确执行时，会抛出`EvalError`错误。该错误类型已经不再使用了，只是为了保证与以前代码兼容，才继续保留。\n\n### 总结\n\n以上这6种派生错误，连同原始的`Error`对象，都是构造函数。开发者可以使用它们，手动生成错误对象的实例。这些构造函数都接受一个参数，代表错误提示信息（message）。\n\n```javascript\nvar err1 = new Error(\'出错了！\');\nvar err2 = new RangeError(\'出错了，变量超出有效范围！\');\nvar err3 = new TypeError(\'出错了，变量类型无效！\');\n\nerr1.message // "出错了！"\nerr2.message // "出错了，变量超出有效范围！"\nerr3.message // "出错了，变量类型无效！"\n```\n\n## 自定义错误\n\n除了 JavaScript 原生提供的七种错误对象，还可以定义自己的错误对象。\n\n```javascript\nfunction UserError(message) {\n  this.message = message || \'默认信息\';\n  this.name = \'UserError\';\n}\n\nUserError.prototype = new Error();\nUserError.prototype.constructor = UserError;\n```\n\n上面代码自定义一个错误对象`UserError`，让它继承`Error`对象。然后，就可以生成这种自定义类型的错误了。\n\n```javascript\nnew UserError(\'这是自定义的错误！\');\n```\n\n## throw 语句\n\n`throw`语句的作用是手动中断程序执行，抛出一个错误。\n\n```javascript\nif (x <= 0) {\n  throw new Error(\'x 必须为正数\');\n}\n// Uncaught ReferenceError: x is not defined\n```\n\n上面代码中，如果变量`x`小于等于`0`，就手动抛出一个错误，告诉用户`x`的值不正确，整个程序就会在这里中断执行。可以看到，`throw`抛出的错误就是它的参数，这里是一个`Error`实例。\n\n`throw`也可以抛出自定义错误。\n\n```javascript\nfunction UserError(message) {\n  this.message = message || \'默认信息\';\n  this.name = \'UserError\';\n}\n\nthrow new UserError(\'出错了！\');\n// Uncaught UserError {message: "出错了！", name: "UserError"}\n```\n\n上面代码中，`throw`抛出的是一个`UserError`实例。\n\n实际上，`throw`可以抛出任何类型的值。也就是说，它的参数可以是任何值。\n\n```javascript\n// 抛出一个字符串\nthrow \'Error！\';\n// Uncaught Error！\n\n// 抛出一个数值\nthrow 42;\n// Uncaught 42\n\n// 抛出一个布尔值\nthrow true;\n// Uncaught true\n\n// 抛出一个对象\nthrow {\n  toString: function () {\n    return \'Error!\';\n  }\n};\n// Uncaught {toString: ƒ}\n```\n\n对于 JavaScript 引擎来说，遇到`throw`语句，程序就中止了。引擎会接收到`throw`抛出的信息，可能是一个错误实例，也可能是其他类型的值。\n\n## try...catch 结构\n\n一旦发生错误，程序就中止执行了。JavaScript 提供了`try...catch`结构，允许对错误进行处理，选择是否往下执行。\n\n```javascript\ntry {\n  throw new Error(\'出错了!\');\n} catch (e) {\n  console.log(e.name + ": " + e.message);\n  console.log(e.stack);\n}\n// Error: 出错了!\n//   at <anonymous>:3:9\n//   ...\n```\n\n上面代码中，`try`代码块抛出错误（上例用的是`throw`语句），JavaScript 引擎就立即把代码的执行，转到`catch`代码块，或者说错误被`catch`代码块捕获了。`catch`接受一个参数，表示`try`代码块抛出的值。\n\n如果你不确定某些代码是否会报错，就可以把它们放在`try...catch`代码块之中，便于进一步对错误进行处理。\n\n```javascript\ntry {\n  f();\n} catch(e) {\n  // 处理错误\n}\n```\n\n上面代码中，如果函数`f`执行报错，就会进行`catch`代码块，接着对错误进行处理。\n\n`catch`代码块捕获错误之后，程序不会中断，会按照正常流程继续执行下去。\n\n```javascript\ntry {\n  throw "出错了";\n} catch (e) {\n  console.log(111);\n}\nconsole.log(222);\n// 111\n// 222\n```\n\n上面代码中，`try`代码块抛出的错误，被`catch`代码块捕获后，程序会继续向下执行。\n\n`catch`代码块之中，还可以再抛出错误，甚至使用嵌套的`try...catch`结构。\n\n```javascript\nvar n = 100;\n\ntry {\n  throw n;\n} catch (e) {\n  if (e <= 50) {\n    // ...\n  } else {\n    throw e;\n  }\n}\n// Uncaught 100\n```\n\n上面代码中，`catch`代码之中又抛出了一个错误。\n\n为了捕捉不同类型的错误，`catch`代码块之中可以加入判断语句。\n\n```javascript\ntry {\n  foo.bar();\n} catch (e) {\n  if (e instanceof EvalError) {\n    console.log(e.name + ": " + e.message);\n  } else if (e instanceof RangeError) {\n    console.log(e.name + ": " + e.message);\n  }\n  // ...\n}\n```\n\n上面代码中，`catch`捕获错误之后，会判断错误类型（`EvalError`还是`RangeError`），进行不同的处理。\n\n## finally 代码块\n\n`try...catch`结构允许在最后添加一个`finally`代码块，表示不管是否出现错误，都必需在最后运行的语句。\n\n```javascript\nfunction cleansUp() {\n  try {\n    throw new Error(\'出错了……\');\n    console.log(\'此行不会执行\');\n  } finally {\n    console.log(\'完成清理工作\');\n  }\n}\n\ncleansUp()\n// 完成清理工作\n// Uncaught Error: 出错了……\n//    at cleansUp (<anonymous>:3:11)\n//    at <anonymous>:10:1\n```\n\n上面代码中，由于没有`catch`语句块，一旦发生错误，代码就会中断执行。中断执行之前，会先执行`finally`代码块，然后再向用户提示报错信息。\n\n```javascript\nfunction idle(x) {\n  try {\n    console.log(x);\n    return \'result\';\n  } finally {\n    console.log(\'FINALLY\');\n  }\n}\n\nidle(\'hello\')\n// hello\n// FINALLY\n```\n\n上面代码中，`try`代码块没有发生错误，而且里面还包括`return`语句，但是`finally`代码块依然会执行。而且，这个函数的返回值还是`result`。\n\n下面的例子说明，`return`语句的执行是排在`finally`代码之前，只是等`finally`代码执行完毕后才返回。\n\n```javascript\nvar count = 0;\nfunction countUp() {\n  try {\n    return count;\n  } finally {\n    count++;\n  }\n}\n\ncountUp()\n// 0\ncount\n// 1\n```\n\n上面代码说明，`return`语句里面的`count`的值，是在`finally`代码块运行之前就获取了。\n\n下面是`finally`代码块用法的典型场景。\n\n```javascript\nopenFile();\n\ntry {\n  writeFile(Data);\n} catch(e) {\n  handleError(e);\n} finally {\n  closeFile();\n}\n```\n\n上面代码首先打开一个文件，然后在`try`代码块中写入文件，如果没有发生错误，则运行`finally`代码块关闭文件；一旦发生错误，则先使用`catch`代码块处理错误，再使用`finally`代码块关闭文件。\n\n下面的例子充分反映了`try...catch...finally`这三者之间的执行顺序。\n\n```javascript\nfunction f() {\n  try {\n    console.log(0);\n    throw \'bug\';\n  } catch(e) {\n    console.log(1);\n    return true; // 这句原本会延迟到 finally 代码块结束再执行\n    console.log(2); // 不会运行\n  } finally {\n    console.log(3);\n    return false; // 这句会覆盖掉前面那句 return\n    console.log(4); // 不会运行\n  }\n\n  console.log(5); // 不会运行\n}\n\nvar result = f();\n// 0\n// 1\n// 3\n\nresult\n// false\n```\n\n上面代码中，`catch`代码块结束执行之前，会先执行`finally`代码块。\n\n`catch`代码块之中，触发转入`finally`代码块的标志，不仅有`return`语句，还有`throw`语句。\n\n```javascript\nfunction f() {\n  try {\n    throw \'出错了！\';\n  } catch(e) {\n    console.log(\'捕捉到内部错误\');\n    throw e; // 这句原本会等到finally结束再执行\n  } finally {\n    return false; // 直接返回\n  }\n}\n\ntry {\n  f();\n} catch(e) {\n  // 此处不会执行\n  console.log(\'caught outer "bogus"\');\n}\n\n//  捕捉到内部错误\n```\n\n上面代码中，进入`catch`代码块之后，一遇到`throw`语句，就会去执行`finally`代码块，其中有`return false`语句，因此就直接返回了，不再会回去执行`catch`代码块剩下的部分了。\n\n`try`代码块内部，还可以再使用`try`代码块。\n\n```javascript\ntry {\n  try {\n    consle.log(\'Hello world!\'); // 报错\n  }\n  finally {\n    console.log(\'Finally\');\n  }\n  console.log(\'Will I run?\');\n} catch(error) {\n  console.error(error.message);\n}\n// Finally\n// consle is not defined\n```\n\n上面代码中，`try`里面还有一个`try`。内层的`try`报错（`console`拼错了），这时会执行内层的`finally`代码块，然后抛出错误，被外层的`catch`捕获。\n\n## 参考连接\n\n- Jani Hartikainen, [JavaScript Errors and How to Fix Them](http://davidwalsh.name/fix-javascript-errors)', 'title': 'javascript：错误处理', 'categories': ['[随笔分类]FrontEnd~JavaScript'], 'enclosure': {'length': 0}, 'link': 'https://www.cnblogs.com/wbyixx/p/12496844.html', 'permalink': 'https://www.cnblogs.com/wbyixx/p/12496844.html', 'postid': '12496844', 'source': {}, 'userid': '-2'}