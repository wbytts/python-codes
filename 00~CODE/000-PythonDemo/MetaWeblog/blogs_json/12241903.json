{'dateCreated': <DateTime '20200130T00:12:00' at 0x1a4f299db48>, 'description': 'Mat对象：图像文件的内存数据对象\n\n![](https://img2018.cnblogs.com/blog/1446249/202001/1446249-20200129232047316-1209938967.png)\n\n# 读取为 Mat 对象\n\n读取图像位Mat对象，获取图像的相关信息\n```c++\n#include <opencv2/opencv.hpp>\n#include <iostream>\n\nusing namespace cv;\nusing namespace std;\n\nint main(int argc, char** argv)\n{\n\n    Mat src = imread("f:/temp/images/lena.jpg", IMREAD_GRAYSCALE);\n\n    if (src.empty())\n    {\n        printf("Could not find the image!\\n");\n        return -1;\n    }\n\n\n    namedWindow("002-demo", WINDOW_AUTOSIZE);\n    imshow("002-demo", src);\n\n    // 获取图像的宽度\n    int width = src.cols;\n    // 获取图像的高度\n    int height = src.rows;\n    // 获取图像的通道数\n    int dim = src.channels();\n    int depth = src.depth();\n    int type = src.type();\n\n    if (type == CV_8UC1)\n    {\n        printf("type：CV_8UC1\\n");\n    }\n\n    // 这里打印出来depth和type有时候为0，并不代表深度为0，而是代表一个枚举类型的值\n    printf("width: %d, height: %d, dim: %d, depth: %d, type: %d\\n", width, height, dim, depth, type);\n\n   \n    waitKey(0);\n    destroyAllWindows();\n\n    return 0;\n}\n```\n\n图像的类型与结构信息：\n![](https://img2018.cnblogs.com/blog/1446249/202001/1446249-20200130000700849-1645887023.png)\n```c++\n#ifndef OPENCV_CORE_HAL_INTERFACE_H\n#define OPENCV_CORE_HAL_INTERFACE_H\n\n//! @addtogroup core_hal_interface\n//! @{\n\n//! @name Return codes\n//! @{\n#define CV_HAL_ERROR_OK 0\n#define CV_HAL_ERROR_NOT_IMPLEMENTED 1\n#define CV_HAL_ERROR_UNKNOWN -1\n//! @}\n\n#ifdef __cplusplus\n#include <cstddef>\n#else\n#include <stddef.h>\n#include <stdbool.h>\n#endif\n\n//! @name Data types\n//! primitive types\n//! - schar  - signed 1 byte integer\n//! - uchar  - unsigned 1 byte integer\n//! - short  - signed 2 byte integer\n//! - ushort - unsigned 2 byte integer\n//! - int    - signed 4 byte integer\n//! - uint   - unsigned 4 byte integer\n//! - int64  - signed 8 byte integer\n//! - uint64 - unsigned 8 byte integer\n//! @{\n#if !defined _MSC_VER && !defined __BORLANDC__\n#  if defined __cplusplus && __cplusplus >= 201103L && !defined __APPLE__\n#    include <cstdint>\n#    ifdef __NEWLIB__\n        typedef unsigned int uint;\n#    else\n        typedef std::uint32_t uint;\n#    endif\n#  else\n#    include <stdint.h>\n     typedef uint32_t uint;\n#  endif\n#else\n   typedef unsigned uint;\n#endif\n\ntypedef signed char schar;\n\n#ifndef __IPL_H__\n   typedef unsigned char uchar;\n   typedef unsigned short ushort;\n#endif\n\n#if defined _MSC_VER || defined __BORLANDC__\n   typedef __int64 int64;\n   typedef unsigned __int64 uint64;\n#  define CV_BIG_INT(n)   n##I64\n#  define CV_BIG_UINT(n)  n##UI64\n#else\n   typedef int64_t int64;\n   typedef uint64_t uint64;\n#  define CV_BIG_INT(n)   n##LL\n#  define CV_BIG_UINT(n)  n##ULL\n#endif\n\n#define CV_USRTYPE1 (void)"CV_USRTYPE1 support has been dropped in OpenCV 4.0"\n\n#define CV_CN_MAX     512\n#define CV_CN_SHIFT   3\n#define CV_DEPTH_MAX  (1 << CV_CN_SHIFT)\n\n#define CV_8U   0\n#define CV_8S   1\n#define CV_16U  2\n#define CV_16S  3\n#define CV_32S  4\n#define CV_32F  5\n#define CV_64F  6\n#define CV_16F  7\n\n#define CV_MAT_DEPTH_MASK       (CV_DEPTH_MAX - 1)\n#define CV_MAT_DEPTH(flags)     ((flags) & CV_MAT_DEPTH_MASK)\n\n#define CV_MAKETYPE(depth,cn) (CV_MAT_DEPTH(depth) + (((cn)-1) << CV_CN_SHIFT))\n#define CV_MAKE_TYPE CV_MAKETYPE\n\n#define CV_8UC1 CV_MAKETYPE(CV_8U,1)\n#define CV_8UC2 CV_MAKETYPE(CV_8U,2)\n#define CV_8UC3 CV_MAKETYPE(CV_8U,3)\n#define CV_8UC4 CV_MAKETYPE(CV_8U,4)\n#define CV_8UC(n) CV_MAKETYPE(CV_8U,(n))\n\n#define CV_8SC1 CV_MAKETYPE(CV_8S,1)\n#define CV_8SC2 CV_MAKETYPE(CV_8S,2)\n#define CV_8SC3 CV_MAKETYPE(CV_8S,3)\n#define CV_8SC4 CV_MAKETYPE(CV_8S,4)\n#define CV_8SC(n) CV_MAKETYPE(CV_8S,(n))\n\n#define CV_16UC1 CV_MAKETYPE(CV_16U,1)\n#define CV_16UC2 CV_MAKETYPE(CV_16U,2)\n#define CV_16UC3 CV_MAKETYPE(CV_16U,3)\n#define CV_16UC4 CV_MAKETYPE(CV_16U,4)\n#define CV_16UC(n) CV_MAKETYPE(CV_16U,(n))\n\n#define CV_16SC1 CV_MAKETYPE(CV_16S,1)\n#define CV_16SC2 CV_MAKETYPE(CV_16S,2)\n#define CV_16SC3 CV_MAKETYPE(CV_16S,3)\n#define CV_16SC4 CV_MAKETYPE(CV_16S,4)\n#define CV_16SC(n) CV_MAKETYPE(CV_16S,(n))\n\n#define CV_32SC1 CV_MAKETYPE(CV_32S,1)\n#define CV_32SC2 CV_MAKETYPE(CV_32S,2)\n#define CV_32SC3 CV_MAKETYPE(CV_32S,3)\n#define CV_32SC4 CV_MAKETYPE(CV_32S,4)\n#define CV_32SC(n) CV_MAKETYPE(CV_32S,(n))\n\n#define CV_32FC1 CV_MAKETYPE(CV_32F,1)\n#define CV_32FC2 CV_MAKETYPE(CV_32F,2)\n#define CV_32FC3 CV_MAKETYPE(CV_32F,3)\n#define CV_32FC4 CV_MAKETYPE(CV_32F,4)\n#define CV_32FC(n) CV_MAKETYPE(CV_32F,(n))\n\n#define CV_64FC1 CV_MAKETYPE(CV_64F,1)\n#define CV_64FC2 CV_MAKETYPE(CV_64F,2)\n#define CV_64FC3 CV_MAKETYPE(CV_64F,3)\n#define CV_64FC4 CV_MAKETYPE(CV_64F,4)\n#define CV_64FC(n) CV_MAKETYPE(CV_64F,(n))\n\n#define CV_16FC1 CV_MAKETYPE(CV_16F,1)\n#define CV_16FC2 CV_MAKETYPE(CV_16F,2)\n#define CV_16FC3 CV_MAKETYPE(CV_16F,3)\n#define CV_16FC4 CV_MAKETYPE(CV_16F,4)\n#define CV_16FC(n) CV_MAKETYPE(CV_16F,(n))\n//! @}\n\n//! @name Comparison operation\n//! @sa cv::CmpTypes\n//! @{\n#define CV_HAL_CMP_EQ 0\n#define CV_HAL_CMP_GT 1\n#define CV_HAL_CMP_GE 2\n#define CV_HAL_CMP_LT 3\n#define CV_HAL_CMP_LE 4\n#define CV_HAL_CMP_NE 5\n//! @}\n\n//! @name Border processing modes\n//! @sa cv::BorderTypes\n//! @{\n#define CV_HAL_BORDER_CONSTANT 0\n#define CV_HAL_BORDER_REPLICATE 1\n#define CV_HAL_BORDER_REFLECT 2\n#define CV_HAL_BORDER_WRAP 3\n#define CV_HAL_BORDER_REFLECT_101 4\n#define CV_HAL_BORDER_TRANSPARENT 5\n#define CV_HAL_BORDER_ISOLATED 16\n//! @}\n\n//! @name DFT flags\n//! @{\n#define CV_HAL_DFT_INVERSE        1\n#define CV_HAL_DFT_SCALE          2\n#define CV_HAL_DFT_ROWS           4\n#define CV_HAL_DFT_COMPLEX_OUTPUT 16\n#define CV_HAL_DFT_REAL_OUTPUT    32\n#define CV_HAL_DFT_TWO_STAGE      64\n#define CV_HAL_DFT_STAGE_COLS    128\n#define CV_HAL_DFT_IS_CONTINUOUS 512\n#define CV_HAL_DFT_IS_INPLACE 1024\n//! @}\n\n//! @name SVD flags\n//! @{\n#define CV_HAL_SVD_NO_UV    1\n#define CV_HAL_SVD_SHORT_UV 2\n#define CV_HAL_SVD_MODIFY_A 4\n#define CV_HAL_SVD_FULL_UV  8\n//! @}\n\n//! @name Gemm flags\n//! @{\n#define CV_HAL_GEMM_1_T 1\n#define CV_HAL_GEMM_2_T 2\n#define CV_HAL_GEMM_3_T 4\n//! @}\n\n//! @}\n\n#endif\n```\n\n# 创建 Mat 对象\n\n1. 通过读入一张图像，直接转换为Mat对象\n2. 使用无参数构造函数，创建Mat对象\n3. 使用行、列、类型带这个三个参数的构造函数创建Mat对象\n4. 使用行、列、类型、Scalar向量四个参数的构造函数创建Mat对象\n5. 使用大小、类型两个参数的构造函数创建Mat对象\n6. 使用大小、类型、Scalar向量三个参数的构造函数创建Mat对象\n7. 使用Mat::zeros函数实现，两个参数一个是Size表示图像宽与高另外一个表示类型\n8. 使用Mat::ones函数实现，两个参数一个是Size表示图像宽与高，另外一个表示类型\n\n```c++\n    // 创建mat对象\n    Mat t1 = Mat(256, 256, CV_8UC3);\n    // Scalar(...) 是一个标量，表示一个颜色值\n    // 灰度图像是一个通道的，一个参数就可以\n    t1 = Scalar(0, 0, 255);\n    imshow("t1", t1);\n\n    // 方法2\n    Mat t2 = Mat(Size(512, 512), CV_8UC3);\n    t2 = Scalar(255, 0, 255);\n    imshow("t2", t2);\n\n    // 创建时指定大小\n    Mat t3 = Mat::zeros(Size(256, 256), CV_8UC3);\n    imshow("t3", t3);\n\n    // 从现有的图像create\n    // 只是对象引用的赋值，本质上还是一张图像\n    // 如果对原图像进行修改，t4也会被修改\n    Mat t4 = src; \n    // 克隆，是一个新的对象\n    // 对原图进行修改，t5并不改变\n    Mat t5 = src.clone();\n    imshow("t5", t5);\n\n    // 拷贝\n    Mat t6;\n    src.copyTo(t6);\n    imshow("t6", t6);\n\n    // 创建一个和现有图像大小、类型一样的空白图像\n    Mat t7 = Mat::zeros(src.size(), src.type());\n```\n\n# Mat 像素信息遍历\n\n```c++\n    /*\n    for (int row = 0; row < height; row++) {\n        for (int col = 0; col < width; col++) {\n            if (dim == 3) {\n                Vec3b pixel = src.at<Vec3b>(row, col);\n                int blue = pixel[0];\n                int green = pixel[1];\n                int red = pixel[2];\n                src.at<Vec3b>(row, col)[0] = 255 - blue;\n                src.at<Vec3b>(row, col)[1] = 255 - green;\n                src.at<Vec3b>(row, col)[2] = 255 - red;\n            }\n            if (dim == 1) {\n                int pv = src.at<uchar>(row, col);\n                src.at<uchar>(row, col) = (255 - pv);\n            }\n        }\n    }\n    imshow("fan", src);\n    */\n\n    // 指针方式遍历，并拷贝图像\n    Mat result = Mat::zeros(src.size(), src.type());\n    for (int row = 0; row < height; row++) {\n        uchar* curr_row = src.ptr<uchar>(row);\n        uchar* result_row = result.ptr<uchar>(row);\n        for (int col = 0; col < width; col++) {\n            if (dim == 3) {\n                int blue = *curr_row++;\n                int green = *curr_row++;\n                int red = *curr_row++;\n\n                *result_row++ = blue;\n                *result_row++ = green;\n                *result_row++ = red;\n            }\n            if (dim == 1) {\n                int pv = *curr_row++;\n                *result_row++ = pv;\n            }\n        }\n    }\n    imshow("src", src);\n```\n\n# Mat对象起源\n\n当OpenCV 1.0发布时候没有Mat对象，是个C语言风格的数据结构IPlImage来表示内存中图像对象，但是OpenCV开发者在做复杂图像处理算法分析与计算时候，创建了很多IplImage这样的数据结构，偶尔最后可能忘记释放内存了，这样算法就有了内存泄漏，导致开发者浪费很多精力去寻找这个错误，这个已经跟图像处理算法没有关系了，但是它却困扰了很多OpenCV开发者。Intel发现自己做的库居然这么渣，广大群众不满意，决定从OpenCV 2.0开始使用一个新的内存对象Mat来表示内存中的图像对象。它是C++风格的数据结构，自动实现内存分配与回收，这样OpenCV开发者就再也不用担心因为使用OpenCV的图像对象数据结构而导致内存泄漏问题了。但是仍然有些开发者直到现在还在顽固的使用IplImage这个对象，Intel为了照顾他们，所以允许IplImage对象继续存在，还提供可以把IplImage对象转换成Mat对象的构造函数，作为开源SDK可谓仁至义尽。\n', 'title': 'opencv：Mat对象', 'categories': ['[随笔分类]OpenCV'], 'enclosure': {'length': 0}, 'link': 'https://www.cnblogs.com/wbyixx/p/12241903.html', 'permalink': 'https://www.cnblogs.com/wbyixx/p/12241903.html', 'postid': '12241903', 'source': {}, 'userid': '-2'}