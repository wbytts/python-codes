{'dateCreated': <DateTime '20200201T20:33:00' at 0x1a4f258cf88>, 'description': '# 卷积基本概念\n\n![](https://img2018.cnblogs.com/blog/1446249/202002/1446249-20200201194331918-1427521537.png)\n\n# C++代码实现卷积\n```c++\n#include <opencv2/opencv.hpp>\n#include <iostream>\n\nusing namespace cv;\nusing namespace std;\n\nint main(int argc, char** argv)\n{\n    Mat src = imread("f:/images/lena.jpg");\n    if (src.empty())\n    {\n        printf("Could not find the image!\\n");\n        return -1;\n    }\n\n    namedWindow("input", WINDOW_AUTOSIZE);\n    imshow("input", src);\n\n    int h = src.rows;\n    int w = src.cols;\n    Mat result = src.clone();\n    for (int row = 1; row < h - 1; row++) {\n        for (int col = 1; col < w - 1; col++) {\n            // 3x3卷积核\n            int sb =\n                src.at<Vec3b>(row, col)[0] +\n                src.at<Vec3b>(row - 1, col - 1)[0] +\n                src.at<Vec3b>(row - 1, col)[0] +\n                src.at<Vec3b>(row - 1, col + 1)[0] +\n                src.at<Vec3b>(row, col - 1)[0] +\n                src.at<Vec3b>(row, col + 1)[0] +\n                src.at<Vec3b>(row + 1, col - 1)[0] +\n                src.at<Vec3b>(row + 1, col)[0] +\n                src.at<Vec3b>(row + 1, col + 1)[0];\n            int sg =\n                src.at<Vec3b>(row, col)[1] +\n                src.at<Vec3b>(row - 1, col - 1)[1] +\n                src.at<Vec3b>(row - 1, col)[1] +\n                src.at<Vec3b>(row - 1, col + 1)[1] +\n                src.at<Vec3b>(row, col - 1)[1] +\n                src.at<Vec3b>(row, col + 1)[1] +\n                src.at<Vec3b>(row + 1, col - 1)[1] +\n                src.at<Vec3b>(row + 1, col)[1] +\n                src.at<Vec3b>(row + 1, col + 1)[1];\n            int sr =\n                src.at<Vec3b>(row, col)[2] +\n                src.at<Vec3b>(row - 1, col - 1)[2] +\n                src.at<Vec3b>(row - 1, col)[2] +\n                src.at<Vec3b>(row - 1, col + 1)[2] +\n                src.at<Vec3b>(row, col - 1)[2] +\n                src.at<Vec3b>(row, col + 1)[2] +\n                src.at<Vec3b>(row + 1, col - 1)[2] +\n                src.at<Vec3b>(row + 1, col)[2] +\n                src.at<Vec3b>(row + 1, col + 1)[2];\n            result.at<Vec3b>(row, col)[0] = sb / 9;\n            result.at<Vec3b>(row, col)[1] = sg / 9;\n            result.at<Vec3b>(row, col)[2] = sr / 9;\n        }\n    }\n\n    imshow("result", result);\n\n    waitKey(0);\n    destroyAllWindows();\n\n    return 0;\n}\n```\n\n# blur函数\n\n```c++\n    Mat dst;\n    /*\n       blur参数：\n            src：输入\n            dst：输出\n            ksize：卷积核大小\n            anchor：锚定点，默认(-1,-1)，中心位置（默认是卷积核大小除以2的位置）\n            borderType：边缘处理方式，默认为BORDER_DEFAULT=4\n    */\n    blur(src, dst, Size(3, 3), Point(-1, -1), BORDER_DEFAULT);\n    imshow("dst", dst);\n```\n\n# 卷积边缘处理\n\n卷积处理的时候，边缘像素的填充方法：\n![](https://img2018.cnblogs.com/blog/1446249/202002/1446249-20200201201540036-824927198.png)\n\n边缘在卷积开始前就填充好（知道卷积核大小之后）\n\n![](https://img2018.cnblogs.com/blog/1446249/202002/1446249-20200201202119536-951258046.png)\n\n## 边缘填充 copyMakeBorder\n\n```c++\n    // 边缘填充 copyMakeBorder\n    int border = 8;\n    Mat border_m;\n    copyMakeBorder(src, border_m, border, border, border, border, BORDER_WRAP, Scalar(0, 0, 255));\n    imshow("border fill demo", border_m);\n```', 'title': 'opencv：图像卷积', 'categories': ['[随笔分类]OpenCV'], 'enclosure': {'length': 0}, 'link': 'https://www.cnblogs.com/wbyixx/p/12250034.html', 'permalink': 'https://www.cnblogs.com/wbyixx/p/12250034.html', 'postid': '12250034', 'source': {}, 'userid': '-2'}