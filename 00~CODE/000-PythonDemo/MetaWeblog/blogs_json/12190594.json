{'dateCreated': <DateTime '20200114T10:14:00' at 0x1a4f29eaac8>, 'description': ' \n# 概述\n二叉树的遍历，就是按照一定的规则访问二叉树，\n\n将二叉树的非线性结构转换为二叉树结点的一个线性序列\n\n假设 L, R, V 分别代表遍历一个结点的左子树，右子树，以及访问该结点的操作\n\n则遍历总共有六种规则：\n\n`VLR`    `VRL`    ------ 前序\n\n`LVR`    `RVL`    ------ 中序\n\n`LRV`    `RLV`    ------ 后序\n\n为了方便，以下算法都采用先左后右的三种，先右后左同理\n\n# 三种遍历的递归算法\n当树非空时：按照顺序访问，若是L或者R则递归访问，遇到V就直接访问.\n\n中序遍历的递归算法:\n```c++\ntemplate <class T>\nvoid BinaryTree<T>::inOrder(BinTreeNode<T> *subTree, void(*visit)(BinTreeNode<T> *p))\n{\n    if (subTree != NULL)\n    {\n        InOrder(subTree->leftChild, visit);\n        visit(subTree);\n        InOrder(subTree->rightChild, visit);\n    }\n}\n```\n\n前序遍历的递归算法:\n```c++\ntemplate <class T>\nvoid BinaryTree<T>::PreOrder(BinTreeNode<T> *subTree, void(*visit)(BinTreeNode<T> *p))\n{\n    if (subTree != NULL)\n    {\n        visit(subTree);\n        PreOrder(subTree->leftChild, visit);\n        PreOrder(subTree->rightChild, visit);\n    }\n}\n\n```\n\n后序遍历的递归算法:\n```c++\ntemplate <class T>\nvoid BinaryTree<T>::PostOrder(BinTreeNode<T> *subTree, void(*visit)(BinTreeNode<T> *p))\n{\n    if (subTree != NULL)\n    {\n        PostOrder(subTree->leftChild, visit);\n        PostOrder(subTree->rightChild, visit);\n        visit(subTree);\n    }\n}\n```\n\n为了把一个递归过程改写为一个非递归过程需要利用一个工作栈，记录遍历时的回退路径\n\n# 前序遍历的非递归算法\n前序遍历时，当前结点的访问时机就是当前，\n\n所以只需要在访问左或者右的时候用栈暂存另一边即可\n\n第一种\n\n\t初始化：p取根结点，栈变为空\n\t循环：\n\t\t访问结点\n\t\t预留右子树指针在栈中\n\t\t左子树非空则进入左子树，左子树为空则弹出右子树，下一次循环访问的就是右子树\n```c++\ntemplate <class T>\nvoid BinaryTree<T>::preOrder(void(visit)(BinTreeNode<T> *p))\n{\n    stack<BinTreeNode<T>*> S;\n    BinTreeNode<T> *p = root;\n    S.Push(NULL);\n\n    while (p != NULL)\n    {\n        visit(p);   //访问当前结点\n        if (p->rightChild != NULL)   \n            S.Push(p->rightChild);    //右子树不为空就将右子树进栈\n        if (p->leftChild != NULL)   //左子树不为空下一次循环就访问左子树根结点\n            p = p->leftChild;\n        else                    \n            S.Pop(p);    //左子树为空就释放刚刚保存或者前面保存的右子树，下一次访问\n    }\n}\n```\n另外一种方法：\n\n\t初始化：根结点入栈\n\t循环：\n\t\u3000\t\tp取栈顶元素，访问p\n\t\t   如果右子树存在，右子树进栈\n\t\t   如果左子树存在，左子树进栈\n```c++\ntemplate <class T>\nvoid BinaryTree<T>::PreOrder(void(visit)(BinTreeNode<T> *p))\n{\n    stack<BinTreeNode<T>*> S;\n    BinTreeNode<T> *p;\n    S.Push(root);\n\n    while (p != NULL)\n    {\n        S.Pop(p);\n        visit(p);\n        if (p->rightChild != NULL)\n            S.Push(p->rightChild);\n        if (p->leftChild != NULL)\n            S.Push(p->leftChild);\n    }\n}\n```\n\n# 中序遍历的非递归算法\n中序遍历时，当前结点的访问时机是左孩子为空或者左孩子访问完了\n\n所以栈用来存放当前结点，当左孩子为空时就是访问的时机，\n\n算法描述：\n\n\t初始化：栈为空，p取根结点\n\t\n\t重复以下操作\n\t\n\t\u3000\u3000当p不为空时，p进栈，p指向其左孩子，直到p左为空\n\t\n\t\u3000\u3000若栈非空，出栈一个，访问，p指向其右孩子\n\t\n\t直到p为空，且栈为空（do-while结构）\n\n```c++\ntemplate <class T>\nvoid BinaryTree<T>::InOrder(void(*visit)(BinTreeNode<T> *p))\n{\n    stack<BinTreeNode<T>*> S;\n    BinTreeNode<T> *p = root;\n    do\n    {\n        //左孩子不停入栈，直到左孩子为空\n        while (p != NULL)\n        {\n            S.Push(p);\n            p = p->leftChild;\n        }\n        //执行到此处，说明前一个p的左孩子为空\n        //所以此时应该访问前一个p的父结点，即栈中最后进入的元素\n        if (!S.IsEmpty())\n        {\n            S.Pop(p);\n            visit(p);  //执行到此处，左孩子和父结点都访问完了，所以应该考察右孩子\n            p = p->rightChild;\n        }\n    } while (p != NULL || !S.IsEmpty());\n}\n```\n\n结束条件为栈为空且遍历指针为空。\n\n栈不为空，遍历指针为空表示左子树访问完了，该访问栈里面的结点了\n\n栈为空，但指针不为空时表示右子树还没访问。\n\n \n\n# 后序遍历的非递归算法\n后序遍历的一个重要性质：**当前访问节点的时候，工作栈内的元素顺序刚好是其祖先结点到它的路径**\n\n后序遍历的非递归比前序和中序复杂。\n\n在遍历左子树时不能访问根结点，还要遍历右子树。\n\n右子树遍历完了才能访问根结点。\n\n所以我们要搞清楚的是上次访问时在左子树中还是右子树中。\n\n方法一（结点中增加标志域）：\n\n即每次入栈时，要同时给进栈结点一个标记，在访问完左子树时，还要把栈顶结点的标记改为右。\n\n\n\n \n\n经过分析，访问结点的时机就是其右孩子为空或者右孩子访问完了的时候\n\n总结算法步骤：\n\n\t初始化：栈为空，p取根结点\n\t重复以下操作：\n\t\u3000\u3000当p不为空时，进栈，标记为左，直到左孩子为空\n\t\u3000\u3000定义一个标记，用于判断是否处于左子树，赋值真\n\t\u3000\u3000当处于左子树且栈非空时，\n\t\u3000\u3000\u3000\u3000取出栈顶元素，\n\t\u3000\u3000\u3000\u3000判断标记：\n\t\u3000\u3000\u3000\u3000\u3000\u3000如果是左标记，将其改为右，再放进去，左子树标记改为假，并指向其右孩子\n\t\u3000\u3000\u3000\u3000\u3000\u3000如果是右标记，访问\n\t\n\t直到栈为空\n\n```c++\ntemplate <class T>\nvoid BinaryTree<T>::PostOrder(void(*visit)(BinTreeNode<T> *p))\n{\n    Stack<stkNode<T>> S;\n    stkNode<T> w;\n    BinTreeNode<T> *p = root;\n    do\n    {\n        while (p != NULL)\n        {\n            w.ptr = p;\n            w.tag = L;\n            S.Push(w);\n            p = p->leftChild;\n        }\n        int continue1 = 1;\n        while (continue1 %% !S.IsEmpty())\n        {\n            S.Pop(w);\n            p = w.ptr;\n            switch (w.tag)\n            {\n            case L:\n                w.tag = R;\n                S.Push(w);\n                continue1 = 0;\n                p = p->rightChild;\n                break;\n            case R:\n                visit(p); \n                break;\n            }\n        }\n    } while (!S.IsEmpty());\n    cout << endl;\n}\n \n```\n\n方法二（增加辅助指针，记录最后一次访问的结点）：\n\n\t当 p非空或栈非空时：\n\t\u3000\u3000如果p非空，则p的左孩子进栈\n\t\u3000\u3000否则：\n\t\u3000\u3000\u3000\u3000p取栈顶元素\n\t\u3000\u3000\u3000\u3000如果p右孩子存在且上次没被访问，p指向右孩子\n\t\u3000\u3000\u3000\u3000否则：\n\t\u3000\u3000\u3000\u3000\u3000\u3000出栈\n\t\u3000\u3000\u3000\u3000\u3000\u3000访问p元素\n\t\u3000\u3000\u3000\u3000\u3000\u3000记录访问的结点\n\t\u3000\u3000\u3000\u3000\u3000\u3000p置空\n\n------------------------------------------------------------\n\n另一种写法：\n\n\tp取根结点，last取root，根结点进栈\n\t当栈非空时：\n\t\u3000\u3000p取栈顶元素\n\t\u3000\u3000如果，左右孩子都存在或者右孩子为空last为左孩子或者last为右孩子\n\t\u3000\u3000\u3000\u3000访问p指向结点，last设为p，s出栈\n\t\u3000\u3000否则：\n\t\u3000 \u3000\u3000如果右孩子存在，右孩子进栈\n\t\u3000\u3000\u3000\u3000如果左孩子存在，左孩子进栈\n\n \n\n方法三：\n\n\tp取根结点，栈s为空\n\tp进栈两次\n\t当栈非空时：\n\t\u3000\u3000p取栈顶元素，s出栈\n\t\u3000\u3000\u3000如果栈非空且p等于栈顶元素\n\t\u3000\u3000\u3000\u3000\u3000若p右孩子存在，右孩子进栈两次\n\t\u3000\u3000\u3000\u3000\u3000若p左孩子存在，左孩子进栈两次\n\t\u3000\u3000\u3000否则：\n\t\u3000\u3000\u3000\u3000\u3000访问p指向的结点\n\n \n\n# 二叉树的层次序遍历\n入队顺序即出队顺序，也就是访问顺序\n\n入队时一定要，先上后下，先左后右\n\n\t初始化：p取根结点，根结点入队列\n\t当队列非空时：\n\t\u3000\u3000出队列，访问出来的元素\n\t\u3000\u3000如果出来的元素有左孩子，则其左孩子入队列\n\t\u3000\u3000如果出来的元素有右孩子，则其右孩子入队列\n\n ```c++\n template <class T>\nvoid BinaryTree<T>::levelOrder(void(*visit)(BinTreeNode<T> *p))\n{\n    Queue<BInTreeNode<T>*> Q;\n    BinTreeNode<T> *p = root;\n    Q.EnQueue(p);\n    while (!Q.IsEmpty())\n    {\n        if (p->leftChild != NULL)\n            Q.EnQueue(p->leftChild);\n        if (p->rightChild != NULL)\n            Q.EnQueue(p->rightChild);\n    }\n}\n ```\n ', 'title': '数据结构笔记：二叉树的遍历', 'categories': ['[随笔分类]算法~数据结构基础'], 'enclosure': {'length': 0}, 'link': 'https://www.cnblogs.com/wbyixx/p/12190594.html', 'permalink': 'https://www.cnblogs.com/wbyixx/p/12190594.html', 'postid': '12190594', 'source': {}, 'userid': '-2'}