{'dateCreated': <DateTime '20200315T18:26:00' at 0x1a4f2555348>, 'description': '原文章：https://wangdoc.com/javascript/index.html\n# 严格模式\n\n除了正常的运行模式，JavaScript 还有第二种运行模式：严格模式（strict mode）。顾名思义，这种模式采用更加严格的 JavaScript 语法。\n\n同样的代码，在正常模式和严格模式中，可能会有不一样的运行结果。一些在正常模式下可以运行的语句，在严格模式下将不能运行。\n\n## 设计目的\n\n早期的 JavaScript 语言有很多设计不合理的地方，但是为了兼容以前的代码，又不能改变老的语法，只能不断添加新的语法，引导程序员使用新语法。\n\n严格模式是从 ES5 进入标准的，主要目的有以下几个。\n\n- 明确禁止一些不合理、不严谨的语法，减少 JavaScript 语言的一些怪异行为。\n- 增加更多报错的场合，消除代码运行的一些不安全之处，保证代码运行的安全。\n- 提高编译器效率，增加运行速度。\n- 为未来新版本的 JavaScript 语法做好铺垫。\n\n总之，严格模式体现了 JavaScript 更合理、更安全、更严谨的发展方向。\n\n## 启用方法\n\n进入严格模式的标志，是一行字符串`use strict`。\n\n```javascript\n\'use strict\';\n```\n\n老版本的引擎会把它当作一行普通字符串，加以忽略。新版本的引擎就会进入严格模式。\n\n严格模式可以用于整个脚本，也可以只用于单个函数。\n\n**（1） 整个脚本文件**\n\n`use strict`放在脚本文件的第一行，整个脚本都将以严格模式运行。如果这行语句不在第一行就无效，整个脚本会以正常模式运行。(严格地说，只要前面不是产生实际运行结果的语句，`use strict`可以不在第一行，比如直接跟在一个空的分号后面，或者跟在注释后面。)\n\n```html\n<script>\n  \'use strict\';\n  console.log(\'这是严格模式\');\n</script>\n\n<script>\n  console.log(\'这是正常模式\');\n</script>\n```\n\n上面代码中，一个网页文件依次有两段 JavaScript 代码。前一个`<script>`标签是严格模式，后一个不是。\n\n如果`use strict`写成下面这样，则不起作用，严格模式必须从代码一开始就生效。\n\n```html\n<script>\n  console.log(\'这是正常模式\');\n  \'use strict\';\n</script>\n```\n\n**（2）单个函数**\n\n`use strict`放在函数体的第一行，则整个函数以严格模式运行。\n\n```javascript\nfunction strict() {\n  \'use strict\';\n  return \'这是严格模式\';\n}\n\nfunction strict2() {\n  \'use strict\';\n  function f() {\n    return \'这也是严格模式\';\n  }\n  return f();\n}\n\nfunction notStrict() {\n  return \'这是正常模式\';\n}\n```\n\n有时，需要把不同的脚本合并在一个文件里面。如果一个脚本是严格模式，另一个脚本不是，它们的合并就可能出错。严格模式的脚本在前，则合并后的脚本都是严格模式；如果正常模式的脚本在前，则合并后的脚本都是正常模式。这两种情况下，合并后的结果都是不正确的。这时可以考虑把整个脚本文件放在一个立即执行的匿名函数之中。\n\n```javascript\n(function () {\n  \'use strict\';\n  // some code here\n})();\n```\n\n## 显式报错\n\n严格模式使得 JavaScript 的语法变得更严格，更多的操作会显式报错。其中有些操作，在正常模式下只会默默地失败，不会报错。\n\n### 只读属性不可写\n\n严格模式下，设置字符串的`length`属性，会报错。\n\n```javascript\n\'use strict\';\n\'abc\'.length = 5;\n// TypeError: Cannot assign to read only property \'length\' of string \'abc\'\n```\n\n上面代码报错，因为`length`是只读属性，严格模式下不可写。正常模式下，改变`length`属性是无效的，但不会报错。\n\n严格模式下，对只读属性赋值，或者删除不可配置（non-configurable）属性都会报错。\n\n```javascript\n// 对只读属性赋值会报错\n\'use strict\';\nObject.defineProperty({}, \'a\', {\n  value: 37,\n  writable: false\n});\nobj.a = 123;\n// TypeError: Cannot assign to read only property \'a\' of object #<Object>\n\n// 删除不可配置的属性会报错\n\'use strict\';\nvar obj = Object.defineProperty({}, \'p\', {\n  value: 1,\n  configurable: false\n});\ndelete obj.p\n// TypeError: Cannot delete property \'p\' of #<Object>\n```\n\n### 只设置了取值器的属性不可写\n\n严格模式下，对一个只有取值器（getter）、没有存值器（setter）的属性赋值，会报错。\n\n```javascript\n\'use strict\';\nvar obj = {\n  get v() { return 1; }\n};\nobj.v = 2;\n// Uncaught TypeError: Cannot set property v of #<Object> which has only a getter\n```\n\n上面代码中，`obj.v`只有取值器，没有存值器，对它进行赋值就会报错。\n\n### 禁止扩展的对象不可扩展\n\n严格模式下，对禁止扩展的对象添加新属性，会报错。\n\n```javascript\n\'use strict\';\nvar obj = {};\nObject.preventExtensions(obj);\nobj.v = 1;\n// Uncaught TypeError: Cannot add property v, object is not extensible\n```\n\n上面代码中，`obj`对象禁止扩展，添加属性就会报错。\n\n### eval、arguments 不可用作标识名\n\n严格模式下，使用`eval`或者`arguments`作为标识名，将会报错。下面的语句都会报错。\n\n```javascript\n\'use strict\';\nvar eval = 17;\nvar arguments = 17;\nvar obj = { set p(arguments) { } };\ntry { } catch (arguments) { }\nfunction x(eval) { }\nfunction arguments() { }\nvar y = function eval() { };\nvar f = new Function(\'arguments\', "\'use strict\'; return 17;");\n// SyntaxError: Unexpected eval or arguments in strict mode\n```\n\n### 函数不能有重名的参数\n\n正常模式下，如果函数有多个重名的参数，可以用`arguments[i]`读取。严格模式下，这属于语法错误。\n\n```javascript\nfunction f(a, a, b) {\n  \'use strict\';\n  return a + b;\n}\n// Uncaught SyntaxError: Duplicate parameter name not allowed in this context\n```\n\n### 禁止八进制的前缀0表示法\n\n正常模式下，整数的第一位如果是`0`，表示这是八进制数，比如`0100`等于十进制的64。严格模式禁止这种表示法，整数第一位为`0`，将报错。\n\n```javascript\n\'use strict\';\nvar n = 0100;\n// Uncaught SyntaxError: Octal literals are not allowed in strict mode.\n```\n\n## 增强的安全措施\n\n严格模式增强了安全保护，从语法上防止了一些不小心会出现的错误。\n\n### 全局变量显式声明\n\n正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。\n\n```javascript\n\'use strict\';\n\nv = 1; // 报错，v未声明\n\nfor (i = 0; i < 2; i++) { // 报错，i 未声明\n  // ...\n}\n\nfunction f() {\n  x = 123;\n}\nf() // 报错，未声明就创建一个全局变量\n```\n\n因此，严格模式下，变量都必须先声明，然后再使用。\n\n### 禁止 this 关键字指向全局对象\n\n正常模式下，函数内部的`this`可能会指向全局对象，严格模式禁止这种用法，避免无意间创造全局变量。\n\n```javascript\n// 正常模式\nfunction f() {\n  console.log(this === window);\n}\nf() // true\n\n// 严格模式\nfunction f() {\n  \'use strict\';\n  console.log(this === undefined);\n}\nf() // true\n```\n\n上面代码中，严格模式的函数体内部`this`是`undefined`。\n\n这种限制对于构造函数尤其有用。使用构造函数时，有时忘了加`new`，这时`this`不再指向全局对象，而是报错。\n\n```javascript\nfunction f() {\n  \'use strict\';\n  this.a = 1;\n};\n\nf();// 报错，this 未定义\n```\n\n严格模式下，函数直接调用时（不使用`new`调用），函数内部的`this`表示`undefined`（未定义），因此可以用`call`、`apply`和`bind`方法，将任意值绑定在`this`上面。正常模式下，`this`指向全局对象，如果绑定的值是非对象，将被自动转为对象再绑定上去，而`null`和`undefined`这两个无法转成对象的值，将被忽略。\n\n```javascript\n// 正常模式\nfunction fun() {\n  return this;\n}\n\nfun() // window\nfun.call(2) // Number {2}\nfun.call(true) // Boolean {true}\nfun.call(null) // window\nfun.call(undefined) // window\n\n// 严格模式\n\'use strict\';\nfunction fun() {\n  return this;\n}\n\nfun() //undefined\nfun.call(2) // 2\nfun.call(true) // true\nfun.call(null) // null\nfun.call(undefined) // undefined\n```\n\n上面代码中，可以把任意类型的值，绑定在`this`上面。\n\n### 禁止使用 fn.callee、fn.caller\n\n函数内部不得使用`fn.caller`、`fn.arguments`，否则会报错。这意味着不能在函数内部得到调用栈了。\n\n```javascript\nfunction f1() {\n  \'use strict\';\n  f1.caller;    // 报错\n  f1.arguments; // 报错\n}\n\nf1();\n```\n\n### 禁止使用 arguments.callee、arguments.caller\n\n`arguments.callee`和`arguments.caller`是两个历史遗留的变量，从来没有标准化过，现在已经取消了。正常模式下调用它们没有什么作用，但是不会报错。严格模式明确规定，函数内部使用`arguments.callee`、`arguments.caller`将会报错。\n\n```javascript\n\'use strict\';\nvar f = function () {\n  return arguments.callee;\n};\n\nf(); // 报错\n```\n\n### 禁止删除变量\n\n严格模式下无法删除变量，如果使用`delete`命令删除一个变量，会报错。只有对象的属性，且属性的描述对象的`configurable`属性设置为`true`，才能被`delete`命令删除。\n\n```javascript\n\'use strict\';\nvar x;\ndelete x; // 语法错误\n\nvar obj = Object.create(null, {\n  x: {\n    value: 1,\n    configurable: true\n  }\n});\ndelete obj.x; // 删除成功\n```\n\n## 静态绑定\n\nJavaScript 语言的一个特点，就是允许“动态绑定”，即某些属性和方法到底属于哪一个对象，不是在编译时确定的，而是在运行时（runtime）确定的。\n\n严格模式对动态绑定做了一些限制。某些情况下，只允许静态绑定。也就是说，属性和方法到底归属哪个对象，必须在编译阶段就确定。这样做有利于编译效率的提高，也使得代码更容易阅读，更少出现意外。\n\n具体来说，涉及以下几个方面。\n\n### 禁止使用 with 语句\n\n严格模式下，使用`with`语句将报错。因为`with`语句无法在编译时就确定，某个属性到底归属哪个对象，从而影响了编译效果。\n\n```javascript\n\'use strict\';\nvar v  = 1;\nvar obj = {};\n\nwith (obj) {\n  v = 2;\n}\n// Uncaught SyntaxError: Strict mode code may not include a with statement\n```\n\n### 创设 eval 作用域\n\n正常模式下，JavaScript 语言有两种变量作用域（scope）：全局作用域和函数作用域。严格模式创设了第三种作用域：`eval`作用域。\n\n正常模式下，`eval`语句的作用域，取决于它处于全局作用域，还是函数作用域。严格模式下，`eval`语句本身就是一个作用域，不再能够在其所运行的作用域创设新的变量了，也就是说，`eval`所生成的变量只能用于`eval`内部。\n\n```javascript\n(function () {\n  \'use strict\';\n  var x = 2;\n  console.log(eval(\'var x = 5; x\')) // 5\n  console.log(x) // 2\n})()\n```\n\n上面代码中，由于`eval`语句内部是一个独立作用域，所以内部的变量`x`不会泄露到外部。\n\n注意，如果希望`eval`语句也使用严格模式，有两种方式。\n\n```javascript\n// 方式一\nfunction f1(str){\n  \'use strict\';\n  return eval(str);\n}\nf1(\'undeclared_variable = 1\'); // 报错\n\n// 方式二\nfunction f2(str){\n  return eval(str);\n}\nf2(\'"use strict";undeclared_variable = 1\')  // 报错\n```\n\n上面两种写法，`eval`内部使用的都是严格模式。\n\n### arguments 不再追踪参数的变化\n\n变量`arguments`代表函数的参数。严格模式下，函数内部改变参数与`arguments`的联系被切断了，两者不再存在联动关系。\n\n```javascript\nfunction f(a) {\n  a = 2;\n  return [a, arguments[0]];\n}\nf(1); // 正常模式为[2, 2]\n\nfunction f(a) {\n  \'use strict\';\n  a = 2;\n  return [a, arguments[0]];\n}\nf(1); // 严格模式为[2, 1]\n```\n\n上面代码中，改变函数的参数，不会反应到`arguments`对象上来。\n\n## 向下一个版本的 JavaScript 过渡\n\nJavaScript 语言的下一个版本是 ECMAScript 6，为了平稳过渡，严格模式引入了一些 ES6 语法。\n\n### 非函数代码块不得声明函数\n\nES6 会引入块级作用域。为了与新版本接轨，ES5 的严格模式只允许在全局作用域或函数作用域声明函数。也就是说，不允许在非函数的代码块内声明函数。\n\n```javascript\n\'use strict\';\nif (true) {\n  function f1() { } // 语法错误\n}\n\nfor (var i = 0; i < 5; i++) {\n  function f2() { } // 语法错误\n}\n```\n\n上面代码在`if`代码块和`for`代码块中声明了函数，ES5 环境会报错。\n\n注意，如果是 ES6 环境，上面的代码不会报错，因为 ES6 允许在代码块之中声明函数。\n\n### 保留字\n\n为了向将来 JavaScript 的新版本过渡，严格模式新增了一些保留字（implements、interface、let、package、private、protected、public、static、yield等）。使用这些词作为变量名将会报错。\n\n```javascript\nfunction package(protected) { // 语法错误\n  \'use strict\';\n  var implements; // 语法错误\n}\n```\n\n## 参考链接\n\n- MDN, [Strict mode](https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Functions_and_function_scope/Strict_mode)\n- Dr. Axel Rauschmayer, [JavaScript: Why the hatred for strict mode?](http://www.2ality.com/2011/10/strict-mode-hatred.html)\n- Dr. Axel Rauschmayer，[JavaScript’s strict mode: a summary](http://www.2ality.com/2011/01/javascripts-strict-mode-summary.html)\n- Douglas Crockford, [Strict Mode Is Coming To Town](http://www.yuiblog.com/blog/2010/12/14/strict-mode-is-coming-to-town/)\n- [JavaScript Strict Mode Support](http://java-script.limewebs.com/strictMode/test_hosted.html)', 'title': 'javascript：严格模式', 'categories': ['[随笔分类]FrontEnd~JavaScript'], 'enclosure': {'length': 0}, 'link': 'https://www.cnblogs.com/wbyixx/p/12499143.html', 'permalink': 'https://www.cnblogs.com/wbyixx/p/12499143.html', 'postid': '12499143', 'source': {}, 'userid': '-2'}