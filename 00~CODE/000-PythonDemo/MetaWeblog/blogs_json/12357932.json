{'dateCreated': <DateTime '20200224T17:47:00' at 0x1a4f256ebc8>, 'description': '原文：https://www.cnblogs.com/wchxj/p/8729503.html\n\n# 错误理解\n在开始深入讲解之前，有必要纠正一下大家以前的那些错误看法了。如果你有以下想法，那么你有必要好好阅读本文。\n\n错误理解一：值传递和引用传递，区分的条件是传递的内容，如果是个值，就是值传递。如果是个引用，就是引用传递。\n\n错误理解二：Java是引用传递。\n\n错误理解三：传递的参数如果是普通类型，那就是值传递，如果是对象，那就是引用传递。\n\n# 实参与形参\n\n我们都知道，在Java中定义方法的时候是可以定义参数的。比如Java中的main方法：\n\n`public static void main(String[] args)`\n这里面的args就是参数。参数在程序语言中分为形式参数和实际参数。\n\n形式参数：是在定义函数名和函数体的时候使用的参数,目的是用来接收调用该函数时传入的参数。\n\n \n\n实际参数：在调用有参函数时，主调函数和被调函数之间有数据传递关系。在主调函数中调用一个函数时，函数名后面括号中的参数称为“实际参数”。\n\n简单举个例子：\n```java\npublic static void main(String[] args) {\n   ParamTest pt = new ParamTest();\n   pt.sout("Hollis");//实际参数为 Hollis\n}\n\npublic void sout(String name) { //形式参数为 name\n   System.out.println(name);\n}\n```\n实际参数是调用有参方法的时候真正传递的内容，而形式参数是用于接收实参内容的参数。\n\n# 值传递与引用传递\n\n上面提到了，当我们调用一个有参函数的时候，会把实际参数传递给形式参数。但是，在程序语言中，这个传递过程中传递的两种情况，即值传递和引用传递。我们来看下程序语言中是如何定义和区分值传递和引用传递的。\n\n值传递（pass by value）是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。\n\n \n\n引用传递（pass by reference）是指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。\n\n有了上面的概念，然后大家就可以写代码实践了，来看看Java中到底是值传递还是引用传递 ，于是，最简单的一段代码出来了：\n```java\npublic static void main(String[] args) {\n   ParamTest pt = new ParamTest();\n\n   int i = 10;\n   pt.pass(i );\n   System.out.println("print in main , i is " + i);\n}\n\npublic void pass(int j) {\n   j = 20;\n   System.out.println("print in pass , j is " + j);\n}\n```\n上面的代码中，我们在pass方法中修改了参数j的值，然后分别在pass方法和main方法中打印参数的值。输出结果如下：\n```\nprint in pass , j is 20\nprint in main , i is 10\n```\n可见，pass方法内部对name的值的修改并没有改变实际参数i的值。那么，按照上面的定义，有人得到结论：Java的方法传递是值传递。\n\n但是，很快就有人提出质疑了（哈哈，所以，不要轻易下结论咯。）。然后，他们会搬出以下代码：\n```java\npublic static void main(String[] args) {\n   ParamTest pt = new ParamTest();\n\n   User hollis = new User();\n   hollis.setName("Hollis");\n   hollis.setGender("Male");\n   pt.pass(hollis);\n   System.out.println("print in main , user is " + hollis);\n}\n\npublic void pass(User user) {\n   user.setName("hollischuang");\n   System.out.println("print in pass , user is " + user);\n}\n```\n同样是一个pass方法，同样是在pass方法内修改参数的值。输出结果如下：\n```\nprint in pass , user is User{name=\'hollischuang\', gender=\'Male\'}\nprint in main , user is User{name=\'hollischuang\', gender=\'Male\'}\n```\n经过pass方法执行后，实参的值竟然被改变了，那按照上面的引用传递的定义，实际参数的值被改变了，这不就是引用传递了么。于是，根据上面的两段代码，有人得出一个新的结论：Java的方法中，在传递普通类型的时候是值传递，在传递对象类型的时候是引用传递。\n\n但是，这种表述仍然是错误的。不信你看下面这个参数类型为对象的参数传递：\n```java\npublic static void main(String[] args) {\n   ParamTest pt = new ParamTest();\n\n   String name = "Hollis";\n   pt.pass(name);\n   System.out.println("print in main , name is " + name);\n}\n\npublic void pass(String name) {\n   name = "hollischuang";\n   System.out.println("print in pass , name is " + name);\n}\n```\n上面的代码输出结果为\n```\nprint in pass , name is hollischuang\nprint in main , name is Hollis\n```\n这又作何解释呢？同样传递了一个对象，但是原始参数的值并没有被修改，难道传递对象又变成值传递了？\n\n# Java中的值传递\n\n上面，我们举了三个例子，表现的结果却不一样，这也是导致很多初学者，甚至很多高级程序员对于Java的传递类型有困惑的原因。\n\n其实，我想告诉大家的是，上面的概念没有错，只是代码的例子有问题。来，我再来给大家画一下概念中的重点，然后再举几个真正恰当的例子。\n\n<div style="color:red;">\n值传递（pass by value）是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。\n引用传递（pass by reference）是指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。\n</div>\n\n那么，我来给大家总结一下，值传递和引用传递之前的区别的重点是什么。\n\n\n\n我们上面看过的几个pass的例子中，都只关注了实际参数内容是否有改变。如传递的是User对象，我们试着改变他的name属性的值，然后检查是否有改变。其实，在实验方法上就错了，当然得到的结论也就有问题了。\n\n为什么说实验方法错了呢？这里我们来举一个形象的例子。再来深入理解一下值传递和引用传递，然后你就知道为啥错了。\n\n你有一把钥匙，当你的朋友想要去你家的时候，如果你直接把你的钥匙给他了，这就是引用传递。这种情况下，如果他对这把钥匙做了什么事情，比如他在钥匙上刻下了自己名字，那么这把钥匙还给你的时候，你自己的钥匙上也会多出他刻的名字。\n\n \n\n你有一把钥匙，当你的朋友想要去你家的时候，你复刻了一把新钥匙给他，自己的还在自己手里，这就是值传递。这种情况下，他对这把钥匙做什么都不会影响你手里的这把钥匙。\n\n \n\n但是，不管上面哪种情况，你的朋友拿着你给他的钥匙，进到你的家里，把你家的电视砸了。那你说你会不会受到影响？而我们在pass方法中，改变user对象的name属性的值的时候，不就是在“砸电视”么。你改变的不是那把钥匙，而是钥匙打开的房子。\n\n还拿上面的一个例子来举例，我们真正的改变参数，看看会发生什么？\n```java\npublic static void main(String[] args) {\n   ParamTest pt = new ParamTest();\n\n   User hollis = new User();\n   hollis.setName("Hollis");\n   hollis.setGender("Male");\n   pt.pass(hollis);\n   System.out.println("print in main , user is " + hollis);\n}\n\npublic void pass(User user) {\n   user = new User();\n   user.setName("hollischuang");\n   user.setGender("Male");\n   System.out.println("print in pass , user is " + user);\n}\n```\n上面的代码中，我们在pass方法中，改变了user对象，输出结果如下：\n```\nprint in pass , user is User{name=\'hollischuang\', gender=\'Male\'}\nprint in main , user is User{name=\'Hollis\', gender=\'Male\'}\n```\n我们来画一张图，看一下整个过程中发生了什么，然后我再告诉你，为啥Java中只有值传递。\n\n![](https://img2018.cnblogs.com/blog/1446249/202002/1446249-20200224174404329-1861757371.png)\n\n稍微解释下这张图，当我们在main中创建一个User对象的时候，在堆中开辟一块内存，其中保存了name和gender等数据。然后hollis持有该内存的地址0x123456（图1）。\n\n当尝试调用pass方法，并且hollis作为实际参数传递给形式参数user的时候，会把这个地址0x123456交给user，这时，user也指向了这个地址（图2）。\n\n然后在pass方法内对参数进行修改的时候，即user = new User();，会重新开辟一块0X456789的内存，赋值给user。后面对user的任何修改都不会改变内存0X123456的内容（图3）。\n\n上面这种传递是什么传递？肯定不是引用传递，如果是引用传递的话，在执行user = new User();的时候，实际参数的引用也应该改为指向0X456789，但是实际上并没有。\n\n通过概念我们也能知道，这里是把实际参数的引用的地址**复制**了一份，传递给了形式参数。所以，**上面的参数其实是值传递，把实参对象引用的地址当做值传递给了形式参数**。\n\n我们再来回顾下之前的那个“砸电视”的例子，看那个例子中的传递过程发生了什么。\n\n![](https://img2018.cnblogs.com/blog/1446249/202002/1446249-20200224174420458-867091428.png)\n\n同样的，在参数传递的过程中，实际参数的地址0X1213456被拷贝给了形参，只是，在这个方法中，并没有对形参本身进行修改，而是修改的形参持有的地址中存储的内容。\n\n所以，**值传递和引用传递的区别并不是传递的内容。而是实参到底有没有被复制一份给形参**。在判断实参内容有没有受影响的时候，要看传的的是什么，如果你传递的是个地址，那么就看这个地址的变化会不会有影响，而不是看地址指向的对象的变化。就像钥匙和房子的关系。\n\n那么，既然这样，为啥上面同样是传递对象，传递的String对象和User对象的表现结果不一样呢？我们在pass方法中使用name = "hollischuang";试着去更改name的值，阴差阳错的直接改变了name的引用的地址。因为这段代码，会new一个String，再把引用交给name，即等价于：\n\nname = new String("hollischuang");\n而原来的那个"Hollis"字符串还是由实参持有着的，所以，并没有修改到实际参数的值。\n\n![](https://img2018.cnblogs.com/blog/1446249/202002/1446249-20200224174434440-1293790830.png)\n\n所以说，**Java中其实还是值传递的，只不过对于对象参数，值的内容是对象的引用**。\n\n# 总结\n\n无论是值传递还是引用传递，其实都是一种求值策略(Evaluation strategy)。在求值策略中，还有一种叫做按共享传递(call by sharing)。其实Java中的参数传递严格意义上说应该是按共享传递。\n\n按共享传递，是指在调用函数时，传递给函数的是实参的地址的拷贝（如果实参在栈中，则直接拷贝该值）。在函数内部对参数进行操作时，需要先拷贝的地址寻找到具体的值，再进行操作。如果该值在栈中，那么因为是直接拷贝的值，所以函数内部对参数进行操作不会对外部变量产生影响。如果原来拷贝的是原值在堆中的地址，那么需要先根据该地址找到堆中对应的位置，再进行操作。因为传递的是地址的拷贝所以函数内对值的操作对外部变量是可见的。\n\n简单点说，Java中的传递，是值传递，而这个值，实际上是对象的引用。\n\n而**按共享传递其实只是按值传递的一个特例**罢了。所以我们可以说Java的传递是按共享传递，或者说Java中的传递是值传递。\n', 'title': '转：为什么说Java中只有值传递', 'categories': ['[随笔分类]Java~JavaSE'], 'enclosure': {'length': 0}, 'link': 'https://www.cnblogs.com/wbyixx/p/12357932.html', 'permalink': 'https://www.cnblogs.com/wbyixx/p/12357932.html', 'postid': '12357932', 'source': {}, 'userid': '-2'}