{'dateCreated': <DateTime '20191202T13:19:00' at 0x1a4f2a26ac8>, 'description': '# 手动遍历对象拷贝\n```\n/**\n * 深拷贝\n * @param {*} obj 拷贝对象(object or array)\n * @param {*} cache 缓存数组\n */\nfunction deepCopy (obj, cache = []) {\n  // typeof [] => \'object\'\n  // typeof {} => \'object\'\n  if (obj === null || typeof obj !== \'object\') {\n    return obj\n  }\n  // 如果传入的对象与缓存的相等, 则递归结束, 这样防止循环\n  /**\n   * 类似下面这种\n   * var a = {b:1}\n   * a.c = a\n   * 资料: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Cyclic_object_value\n   */\n  const hit = cache.filter(c => c.original === obj)[0]\n  if (hit) {\n    return hit.copy\n  }\n\n  const copy = Array.isArray(obj) ?  [] :   {}\n  // 将copy首先放入cache, 因为我们需要在递归deepCopy的时候引用它\n  cache.push({\n    original: obj,\n    copy\n  })\n  Object.keys(obj).forEach(key => {\n    copy[key] = deepCopy(obj[key], cache)\n  })\n\n  return copy\n}\n```\n\n# 使用JSON模块\n根据不包含引用对象的普通数组深拷贝得到启发，不拷贝引用对象，拷贝一个字符串会新辟一个新的存储地址，这样就切断了引用对象的指针联系。\n\n测试例子：\n```js\nvar test={\n    a:"ss",\n    b:"dd",\n    c:[\n        {dd:"css",ee:"cdd"},\n        {mm:"ff",nn:"ee"}\n    ]\n};\nvar test1 = JSON.parse(JSON.stringify(test));//拷贝数组,注意这行的拷贝方法\nconsole.log(test);\nconsole.log(test1);\ntest1.c[0].dd="change"; //改变test1的c属性对象的d属性\nconsole.log(test);  //不影响test\nconsole.log(test1);\n```\n\nJSON.parse(),JSON.stringify()兼容性问题\n可以通过为IE7以及IE7以下版本的IE浏览器引入json2.js，使用json2.js来解决JSON的兼容性问题\n```\n<!--[if lt IE 7]>\n<script src="具体放路径/json2.js"></script> \n<![endif]-->\n```\njson2.js的github地址为：[https://github.com/douglascrockford/JSON-js](https://github.com/douglascrockford/JSON-js)\n', 'title': 'JS实现对对象的深拷贝', 'categories': ['[随笔分类]FrontEnd~JavaScript'], 'enclosure': {'length': 0}, 'link': 'https://www.cnblogs.com/wbyixx/p/11969980.html', 'permalink': 'https://www.cnblogs.com/wbyixx/p/11969980.html', 'postid': '11969980', 'source': {}, 'userid': '-2'}