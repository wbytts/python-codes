{'dateCreated': <DateTime '20191205T09:55:00' at 0x1a4f2a21c48>, 'description': '**官方文档：https://pyautogui.readthedocs.io/en/latest/#**\n\n# 安装pyautogui模块\n\n在 Windows 上，不需要安装其他模块。\n在 OS X 上，运行 sudo pip3 install pyobjc-framework-Quartz，sudo pip3 install pyobjc-core，然后 sudo pip3 install pyobjc。\n在 Linux 上，运行 sudo pip3 install python3-xlib，sudo apt-get install scrot，sudo apt-get install python3-tk，以及 sudo apt-get install python3-dev（Scrot 是PyAutoGUI 使用的屏幕快照程序）。\n\n在这些依赖安装后，运行 pip install pyautogui （或在 OS X 和 Linux 上运行 pip3），安装 pyautogui。\n\n# 注意事项\n\n有时候自动控制键盘鼠标的测试程序可能会导致人工无法停止的状态\n\n## 通过注销关闭所有程序\n\n停止失去控制的 GUI 自动化程序，最简单的方法可能是注销，这将关闭所有运行的程序。在 Windows 和 Linux 上，注销的热键是 Ctrl-Alt-Del。在 OS X，热键是 -Shift-Option-Q。通过注销，你会丢失所有未保存的工作，但至少不需要等计算机完全重启。\n\n## 暂停和自动防故障装置\n\n你可以告诉脚本在每次函数调用后等一会儿，在出问题的时候，让你有很短的时间窗口来控制鼠标和键盘。要做到这一点，将 pyautogui.PAUSE 变量设置为要暂停的秒数。例如，在设置 pyautogui.PAUSE = 1.5 之后，每个 PyAutoGUI 函数调用在执行动作之后，都会等待一秒半。非 PyAutoGUI 指令不会停顿。\n\npyautogui 也有自动防故障功能。将鼠标移到屏幕的左上角，这将导致 pyautogui产生 pyautogui .FailSafeException 异常。你的程序可以用 try 和 except 语句来处理这个异常，也可以让异常导致程序崩溃。这两种情况下，如果你尽可能快地向左上移动鼠标，自动防故障功能都将停止程序。可以设置 pyautogui. FAILSAFE = False，禁止这项功能。\n\n我们导入 pyautogui，并将 pyautogui.PAUSE 设置为 1，即每次函数调用后暂停一秒。将 pyautogui.FAILSAFE 设置为 True，启动自动防故障功能。\n\n# 控制鼠标\n\n## 屏幕的坐标\n![屏幕坐标](https://www.github.com/wbytts/images/raw/master/xsj/1562337315697.png)\n\n`pyautogui.size()` 函数返回两个整数的元组，包含屏幕的宽和高的像素数。\n\n## 移动鼠标\n\n`pyautogui.moveTo(x, y, duration=..)`\n* x，y：移动到的坐标位置\n* duration：移动所花费的时间；默认值为0，表示立刻到终点；\n\n## 获取鼠标的位置\n\n`pyautogui.position()`\n这个函数返回鼠标当前位置x，y的元组；\n\n小例子：现在鼠标在哪里？\n```python\nimport pyautogui\n\ntry:\n    print("按Ctrl+C结束:")\n    while True:\n        x, y = pyautogui.position()\n        positionStr = \'X: \' + str(x).rjust(4) + \' Y: \' + str(y).rjust(4)\n        print(positionStr, end=\'\')\n        print(\'\\b\' * len(positionStr), end=\'\', flush=True)\nexcept:\n    pass\n```\n\n## 点击鼠标\n\n`pyautogui.click(x, y, button=.. )`\n* x和y为鼠标点击的坐标\n* button指定是鼠标哪个键点击;默认为鼠标左键；可选（left, right, middle）\n\n`pyautogui.doubleClick()`：鼠标左键双击\n`pyautogui.rightClick()`：鼠标右键单击\n`pyautogui.middleClick()`：鼠标中键单击\n\n另外还有：`pyautogui. mouseDown()` 和 `pyautogui.mouseUp()`类似，分别是鼠标按下和鼠标抬起。\n\n## 拖动鼠标\n\n* `pyautogui.dragTo()`：拖动到指定位置\n* ` pyautogui.dragRel()`：按偏移量进行拖动\n\n\n一个小例子：\n```python\nimport pyautogui\nimport time\ntime.sleep(5)\npyautogui.click()  # click to put drawing program in focus\ndistance = 200\nwhile distance > 0:\n    pyautogui.dragRel(distance, 0, duration=0.05)  # move right\n    distance = distance - 5\n    pyautogui.dragRel(0, distance, duration=0.05)  # move down\n    pyautogui.dragRel(-distance, 0, duration=0.05)  # move left\n    distance = distance - 5\n    pyautogui.dragRel(0, -distance, duration=0.05)  # move up\n```\n打开画图工具，选择画笔，然后运行这个程序，将鼠标放在画板上，5秒后，它就会画出一个图形：\n![enter description here](https://www.github.com/wbytts/images/raw/master/xsj/1562338634073.png)\n\n## 滚动鼠标\n\n* `pyautogui.scroll()`：要一个整型参数，说明向上或向下滚动多少单位。单位的意义在每个操作系统和应用上不一样，所以你必须试验，看看在你的情况下滚动多远。滚动发生在鼠标的当前位置。传递正整数表示向上滚动，传递负整数表示向下滚动\n\n# 处理屏幕\n\n在 Linux 计算机上，需要安装 scrot 程序，才能在 pyautogui 中使用屏幕快照功能。在终端窗口中，执行 sudo apt-get install scrot，安装该程序。如果你使用 Windows或 OS X，就跳过这一步\n\n## 获取屏幕快照\n\n要在 Python 中获取屏幕快照，就调用 pyautogui.screenshot() 函数：`im = pyautogui.screenshot()`\n\nim 变量将包含一个屏幕快照的 Image 对象。现在可以调用 im 变量中 Image 对象的方法，就像所有其他 Image 对象一样。\n\n向 getpixel() 函数传入坐标元组，如（0，0）或（50，200），它将告诉你图像中这些坐标处的像素颜色。getpixel() 函数的返回值是一个RGB 元组，包含3 个整数，表示像素的红绿蓝值（没有第四个值表示 alpha，因为屏幕快照是完全不透明的）。这就是你的程序“看到”当前屏幕上内容的方法。\n\n## 分析屏幕快照\n\n如果屏幕上指定的 x、y 坐标处的像素与指定的颜色匹配，PyAutoGUI 的pixelMatchesColor() 函数将返回 True。第一和第二个参数是整数，对应 x 和 y 坐标。第三个参数是一个元组，包含 3 个整数，是屏幕像素必须匹配的 RGB 颜色。\n\n在获取屏幕快照，并用 getpixel() 函数取得特定坐标处像素颜色的 RGB 元组之后，将同样的坐标和 RGB 元组传递给 pixelMatchesColor()，这应该返回 True。然后改变 RBG 元组中的一个值，用同样的坐标再次调用 pixelMatches Color()，这应该返回 False。你的 GUI 自动化程序要调用 click() 之前，这种方法应该有用。请注意，给定坐标处的颜色应该“完全”匹配。即使只是稍有差异（例如，是（255，255，254）而不是（255，255，255）），那么函数也会返回 False。\n\n## 图像识别\n\n`locateOnScreen(\'图像\')` 函数返回４个整数的元组，是屏幕上首次发现该图像时左边的x 坐标、顶边的 y 坐标、宽度以及高度\n\n如果屏幕上找不到该图像，locateOnScreen() 函数将返回 None。请注意要成功识别，屏幕上的图像必须与提供的图像完全匹配。即使只差一个像素，locateOnScreen() 函数也会返回 None。\n\n如果该图像在屏幕上能够找到多处，locateAllOnScreen() 函数将返回一个Generator 对象。可以将它传递给 list() ，返回一个 4 整数元组的列表。每个４整数元组代表了屏幕上的一个区域。如果图像只找到一次，返回的列表就只包含一个元组。\n\n在得到图像所在屏幕区域的 4 整数元组后，就可以点击这个区域的中心。将元组传递给 center() 函数，它将返回该区域中心的 x、y 坐标。\n\n# 控制键盘\n\n## 通过键盘发送一个字符串\n\npyautogui.typewrite() 函数向计算机发送虚拟按键。\n\n```python\npyautogui.typewrite(\'Hello world!\')\n```\n\n默认情况下，typewrite() 函数将立即打印出完整字符串。但是，你可以传入可选的第二参数，在每个字符之间添加短时间暂停。例如，pyautogui.typewrite（\'Helloworld!\'，0.25）将在打出H 后等待1/4 秒。打出e 以后再等待1/4 秒，如此等等。这种渐进的打字机效果，对于较慢的应用可能有用，它们处理击键的速度不够快，跟不上pyautogui。对于 A 或!这样的字符，pyautogui 将自动模拟按住 Shift 键。\n\n## 键名\n\n不是所有的键都很容易用单个文本字符来表示, 在PyAutoGUI 中，这些键表示为短的字符串值：\'esc\' 表示Esc 键，\'enter\' 表示 Enter。\n除了单个字符串参数，还可以向 typewrite() 函数传递这些键字符串的列表\n\n> 也可以查看 pyautogui.KEYBOARD_KEYS 列表，看看 pyautogui 接受的所有可能的键字符串\n\n## 按下和释放键盘\n\npyautogui.keyDown() 和 pyautogui.keyUp() 将向计算发送虚拟的按键和释放\npyautogui提供了pyautogui.press() 函数，它调用这两个函数，模拟完整的击键。\n\n## 热键组合\n\n“热键”或“快捷键”是一种按键组合，它调用某种应用功能\n可以使用按下抬起的组合，但是相当麻烦\n可以使用 pyautogui.hotkey() 函数，它接受多个键字符串参数，按顺序按下，再按相反的顺序释放\n\n# 常用函数总结\n\n`moveTo(x，y)`将鼠标移动到指定的 x、y 坐标。\n`moveRel(xOffset，yOffset)`相对于当前位置移动鼠标。\n`dragTo(x，y)`按下左键移动鼠标。\n`dragRel(xOffset，yOffset)`按下左键，相对于当前位置移动鼠标。\n`click(x，y，button)`模拟点击（默认是左键）。\n`rightClick()` 模拟右键点击。\n`middleClick()` 模拟中键点击。\n`doubleClick()`模拟左键双击。\n`mouseDown(x，y，button)`模拟在 x、y 处按下指定鼠标按键。\n`mouseUp(x，y，button)`模拟在 x、y 处释放指定键。\n`scroll(units)`模拟滚动滚轮。正参数表示向上滚动，负参数表示向下滚动。\n`typewrite(message)`键入给定消息字符串中的字符。\n`typewrite([key1，key2，key3])`键入给定键字符串。\n`press（key)`按下并释放给定键。\n`keyDown(key)`模拟按下给定键。\n`keyUp(key)`模拟释放给定键。\n`hotkey([key1，key2，key3])`模拟按顺序按下给定键字符串，然后以相反的顺序释放。\n`screenshot()` 返回屏幕快照的 Image 对象（参见第 17 章关于 Image 对象的信息）。\n\n# 使用pyperclip模块控制剪切板\n\n1.该模块为第三方模块，需安装后使用`pip install pyperclip`\n2.作用：向剪切板发送文本或读取剪切板文本\n3.用法：\n* pyperclip.copy(\'dsd\')#向剪切板发送文本\n* pyperclip.paste()读取剪切板文本\n', 'title': 'Python使用pyautogui控制鼠标键盘', 'categories': ['[随笔分类]Python~'], 'enclosure': {'length': 0}, 'link': 'https://www.cnblogs.com/wbyixx/p/11987317.html', 'permalink': 'https://www.cnblogs.com/wbyixx/p/11987317.html', 'postid': '11987317', 'source': {}, 'userid': '-2'}