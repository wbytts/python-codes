{'dateCreated': <DateTime '20200130T23:38:00' at 0x1a4f299a488>, 'description': '![](https://img2018.cnblogs.com/blog/1446249/202001/1446249-20200130233745389-1033201790.png)\n\n模板匹配的算法：\n![](https://img2018.cnblogs.com/blog/1446249/202001/1446249-20200130234038083-1607003226.png)\n\n\n```python\nimport cv2 as cv\nimport numpy as np\n\n\n# 模板匹配，就是在整个图像区域发现与给定子图像匹配的小块区域，\n# 需要模板图像T和待检测图像-源图像S\n# 工作方法：在待检测的图像上，从左到右，从上倒下计算模板图像与重叠子图像匹配度，\n# 匹配度越大，两者相同的可能性越大。\ndef template_demo():\n    tpl = cv.imread("../images/rabbit.jpg")\n    target = cv.imread("../images/CrystalLiu22.jpg")\n    cv.imshow("template", tpl)\n    cv.imshow("target", target)\n\n    methods = [cv.TM_SQDIFF_NORMED, cv.TM_CCORR_NORMED, cv.TM_CCOEFF_NORMED]  # 三种模板匹配方法\n    th, tw = tpl.shape[:2]\n\n    for md in methods:\n        print(md)\n        result = cv.matchTemplate(target, tpl, md)  # 得到匹配结果\n        min_val, max_val, min_loc, max_loc = cv.minMaxLoc(result)\n        if md == cv.TM_SQDIFF_NORMED:  # cv.TM_SQDIFF_NORMED最小时最相似，其他最大时最相似\n            tl = min_loc\n        else:\n            tl = max_loc\n\n        br = (tl[0] + tw, tl[1] + th)\n        cv.rectangle(target, tl, br, (0, 0, 255), 2)  # tl为左上角坐标，br为右下角坐标，从而画出矩形\n        cv.imshow("match-"+np.str(md), target)\n\nif __name__ == \'__main__\':\n\n    src = cv.imread("../images/CrystalLiu1.jpg")  # 读入图片放进src中\n    cv.namedWindow("Crystal Liu")  # 创建窗口\n    cv.imshow("Crystal Liu", src)  # 将src图片放入该创建的窗口中\n    template_demo()\n\n    cv.waitKey(0) # 等有键输入或者1000ms后自动将窗口消除，0表示只用键输入结束窗口\n    cv.destroyAllWindows()  # 关闭所有窗口\n```', 'title': 'opencv python：模板匹配', 'categories': ['[随笔分类]OpenCV', '[随笔分类]OpenCV~Python', '[随笔分类]OpenCV'], 'enclosure': {'length': 0}, 'link': 'https://www.cnblogs.com/wbyixx/p/12244381.html', 'permalink': 'https://www.cnblogs.com/wbyixx/p/12244381.html', 'postid': '12244381', 'source': {}, 'userid': '-2'}