{'dateCreated': <DateTime '20200217T21:45:00' at 0x1a4f25795c8>, 'description': '轮廓逼近，本质上是减少编码点\n\n拟合圆，生成最相似的圆或椭圆\n\n```c++\n#include <opencv2/opencv.hpp>\n#include <iostream>\n\nusing namespace cv;\nusing namespace std;\nRNG rng(12345);\n\nvoid fit_circle_demo(Mat &image);\n\nint main(int argc, char** argv)\n{\n    //Mat src = imread("f:/images/qq/jihe.png");\n    Mat src = imread("f:/images/qq/stuff.png");\n    if (src.empty())\n    {\n        printf("Could not find the image!\\n");\n        return -1;\n    }\n\n    namedWindow("input", WINDOW_AUTOSIZE);\n    imshow("input", src);\n\n    // 做一个高斯模糊，消除一些细微的东西\n    GaussianBlur(src, src, Size(3, 3), 0);\n\n    Mat gray, binary;\n    cvtColor(src, gray, COLOR_BGR2GRAY);\n    imshow("gray", gray);\n\n    // 二值化\n    threshold(gray, binary, 0, 255, THRESH_BINARY | THRESH_OTSU);\n    imshow("binary", binary);\n\n    vector<vector<Point>> contours;\n    vector<Vec4i> hierarchy;\n    //findContours(binary, contours, hierarchy, RETR_TREE, CHAIN_APPROX_SIMPLE, Point());\n    // 只绘制最外层的轮廓\n    findContours(binary, contours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE, Point());\n\n    fit_circle_demo(src);\n    src = imread("f:/images/qq/stuff.png");\n\n    //多边形逼近演示\n    for (size_t t = 0; t < contours.size(); t++) {\n        Moments mm = moments(contours[t]);\n        // 计算每个轮廓的中心位置\n        double cx = mm.m10 / mm.m00;\n        double cy = mm.m01 / mm.m00;\n        circle(src, Point(cx, cy), 3, Scalar(0, 255, 0), 2, 8, 0);\n\n        double area = contourArea(contours[t]);\n        double clen = arcLength(contours[t], true);\n\n        Mat result;\n        approxPolyDP(contours[t], result, 4, true);\n        printf("corners: %d, colums: %d, contour area: %.2f, contour length: %.2f\\n", result.rows, result.cols, area, clen);\n        if (result.rows == 6) {\n            putText(src, "poly", Point(cx, cy-10), FONT_HERSHEY_PLAIN, 1.0, Scalar(0, 255, 0), 1, 8);\n        }\n        if (result.rows == 4) {\n            putText(src, "rectangle", Point(cx, cy - 10), FONT_HERSHEY_PLAIN, 1.0, Scalar(0, 255, 0), 1, 8);\n        }\n        if (result.rows == 3) {\n            putText(src, "trangle", Point(cx, cy - 10), FONT_HERSHEY_PLAIN, 1.0, Scalar(0, 255, 0), 1, 8);\n        }\n        if (result.rows > 10) {\n            putText(src, "circle", Point(cx, cy - 10), FONT_HERSHEY_PLAIN, 1.0, Scalar(0, 255, 0), 1, 8);\n        }\n    }\n\n    imshow("result", src);\n\n    waitKey(0);\n    destroyAllWindows();\n\n    return 0;\n}\n\nvoid fit_circle_demo(Mat& image) {\n    Mat gray, binary;\n    cvtColor(image, gray, COLOR_BGR2GRAY);\n    // 二值化\n    threshold(gray, binary, 0, 255, THRESH_BINARY | THRESH_OTSU);\n    imshow("binary", binary);\n\n    vector<vector<Point>> contours;\n    vector<Vec4i> hierarchy;\n    //findContours(binary, contours, hierarchy, RETR_TREE, CHAIN_APPROX_SIMPLE, Point());\n    // 只绘制最外层的轮廓\n    findContours(binary, contours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE, Point());\n\n    //拟合圆或者椭圆\n    for (size_t t = 0; t < contours.size(); t++) {\n        //drawContours(image, contours, t, Scalar(0, 0, 255), 2, 8);\n        RotatedRect rrt = fitEllipse(contours[t]);\n        float w = rrt.size.width;\n        float h = rrt.size.height;\n        Point center = rrt.center;\n        circle(image, center, 3, Scalar(255, 0, 0), 2, 8, 0);\n        ellipse(image, rrt, Scalar(0, 255, 0), 2, 8);\n    }\n    imshow("fit demo", image);\n}\n```', 'title': 'opencv：轮廓逼近与拟合', 'categories': ['[随笔分类]OpenCV'], 'enclosure': {'length': 0}, 'link': 'https://www.cnblogs.com/wbyixx/p/12323857.html', 'permalink': 'https://www.cnblogs.com/wbyixx/p/12323857.html', 'postid': '12323857', 'source': {}, 'userid': '-2'}