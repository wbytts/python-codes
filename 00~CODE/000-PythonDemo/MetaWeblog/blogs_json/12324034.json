{'dateCreated': <DateTime '20200217T22:20:00' at 0x1a4f2579208>, 'description': '![](https://img2018.cnblogs.com/blog/1446249/202002/1446249-20200217214643158-1298963507.png)\n![](https://img2018.cnblogs.com/blog/1446249/202002/1446249-20200217215058447-89850502.png)\n\n```c++\n#include <opencv2/opencv.hpp>\n#include <iostream>\n\nusing namespace cv;\nusing namespace std;\n\nvoid hough_linesp_demo();\n\nint main(int argc, char** argv)\n{\n    Mat src = imread("f:/images/qq/tline.png");\n    //Mat src = imread("f:/images/qq/yezi.png");\n    if (src.empty())\n    {\n        printf("Could not find the image!\\n");\n        return -1;\n    }\n\n    namedWindow("input", WINDOW_AUTOSIZE);\n    imshow("input", src);\n\n    // 做一个高斯模糊，消除一些细微的东西\n    //GaussianBlur(src, src, Size(3, 3), 0);\n\n    Mat gray, binary;\n    cvtColor(src, gray, COLOR_BGR2GRAY);\n    imshow("gray", gray);\n\n    // 二值化\n    threshold(gray, binary, 0, 255, THRESH_BINARY | THRESH_OTSU);\n    imshow("binary", binary);\n\n    // 霍夫直线检测\n    vector<Vec3f> lines;\n    HoughLines(binary, lines, 1, CV_PI / 180.0, 100, 0, 0);\n    // 绘制直线\n    Point pt1, pt2;\n    for (size_t i = 0; i < lines.size(); i++) {\n        float rho = lines[i][0]; // 距离\n        float theta = lines[i][1]; // 角度\n        float acc = lines[i][2]; // 累加值\n        printf("rho: %.2f, thrta: %.2f, acc: %.2f\\n", rho, theta, acc);\n        double a = cos(theta);\n        double b = sin(theta);\n        double x0 = a * rho, y0 = b * rho;\n        pt1.x = cvRound(x0 + 1000 * (-b));\n        pt1.y = cvRound(y0 + 1000 * (a));\n        pt2.x = cvRound(x0 - 1000 * (-b));\n        pt2.y = cvRound(y0 - 1000 * (a));\n        int angle = round((theta / CV_PI) * 180);\n        if (rho > 0) { //右倾\n            line(src, pt1, pt2, Scalar(0, 0, 255), 2, 8, 0);\n            if (angle == 90) { // 水平线\n                line(src, pt1, pt2, Scalar(0, 255, 255), 2, 8, 0);\n            }\n            if (angle < 1) { // 近似垂直线\n                line(src, pt1, pt2, Scalar(255, 255, 0), 2, 8, 0);\n            }\n        }\n        else { // 左倾\n            line(src, pt1, pt2, Scalar(255, 0, 0), 2, 8, 0);\n        }\n        \n    }\n    imshow("hough line detection", src);\n    hough_linesp_demo();\n    waitKey(0);\n    destroyAllWindows();\n\n    return 0;\n}\n\nvoid hough_linesp_demo() {\n    Mat src = imread("f:/images/qq/tline.png");\n    Mat gray, binary;\n    Canny(src, binary, 80, 160, 3, false);\n    imshow("canny binary", binary);\n\n    vector<Vec4i> lines;\n    HoughLinesP(binary, lines, 1, CV_PI / 180, 80, 30, 10);\n    Mat result = Mat::zeros(src.size(), src.type());\n    for (int i = 0; i < lines.size(); i++) {\n        line(result, Point(lines[i][0], lines[i][1]), Point(lines[i][2], lines[i][3]), Scalar(0, 0, 255), 2, 8, 0);\n    }\n    imshow("hough linesp demo", result);\n}\n\n```', 'title': 'opencv：霍夫直线检测', 'categories': ['[随笔分类]OpenCV'], 'enclosure': {'length': 0}, 'link': 'https://www.cnblogs.com/wbyixx/p/12324034.html', 'permalink': 'https://www.cnblogs.com/wbyixx/p/12324034.html', 'postid': '12324034', 'source': {}, 'userid': '-2'}