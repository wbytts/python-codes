{'dateCreated': <DateTime '20200120T22:18:00' at 0x1a4f29d0908>, 'description': '# 概念\n\n列表：有序的，可变的，元素集合\n\n因为列表和字符串都是序列类型，所以很多操作和字符串很相似\n但是注意：列表是可变类型，字符串是不可变类型\n\n# 定义\n\n## 基本定义\n\n定义方法：`[ 元素1, 元素2, ...... ]`\n\n列表中的元素是任意的，写什么都可以，也可以是另一个列表\n\n可以定义一个空列表：`[]`\n\n## 列表生成式\n\nrange(stop)：生成 `[0, 1, 2, ...., stop-1]`\nrange(start, stop[, step])：生成 `[start, start+step, start+2*step, ...... ]` ，元素都小于stop\n\n在python2中，range直接返回一个列表，而在python3中，range是一个生成器\n\n使用生成器的原因：为了防止生成的列表会很大，而且可能不会被立即使用\n\n## 列表推导式\n\n`[表达式 for x in xxx]`\n`[表达式 for x in xxx if 条件]`\n`[表达式 for x in xxx for y in yyy]`\n......\n\n# 列表常用操作\n\n## 增加\n\n### append\n\n向列表中，追加一个新的元素，在列表的最后\n\n语法：`l.append(x)`\n\n**会直接修改原列表**，返回值为None\n\n### insert\n\n在列表指定位置追加一个新的元素\n\n在指定索引的前面\n\n语法：`l.insert(index, obj)`\n\n会直接修改原列表\n\n### extend\n\n给列表扩展另外一个可迭代序列\n\n语法：`l.extend(iterable)`\n\n会直接修改原列表\n\n### 乘法操作\n\n`l * n`：列表l，内容重复n次\n\n不修改原列表\n\n### 加法操作\n\n`l1 + l2`：组合l1和l2\n\n不修改原列表\n\n## 删除\n\n### del 语句\n\ndel 语句可以删除一个指定的元素\n（del不止可以用于列表，也可以用于普通变量）\n\ndel可以删除整个列表，也可以删除某个元素\n\n### pop\n\n移除并返回列表中指定索引对应元素\n\n语法：`l.pop(index=-1)`\n\n返回被移除的元素\n\n### remove\n\n移除列表中的指定元素\n\n语法：`l.remove(obj)`\n参数 obj：需要被移除的元素\n\n注意：\n- 会直接修改原列表\n- 如果元素不存在，会报错\n- 如果存在多个元素，则只会删除最左边的一个\n- 注意，在循环中删除列表元素，有时候会有坑\n\n## 修改\n\n`l[index] = xxx`\n\n## 查找\n\n### 索引\n\n`l[index]`\n\n### 获取元素索引\n\n`l.index(obj)`\n\n从左到右进行查找\n\n### 获取指定元素个数\n\n`l.count(obj)`\n\n### 获取多个元素，切片\n\n见字符串操作方法，注意列表是可变的\n\n## 遍历\n\n### 通过元素进行遍历\n\n```python\nfor x in l:\n    ......\n```\n\n### 通过索引进行遍历\n\n```python\nfor index in range(len(l) + 1):\n    ......\n```\n\n### 通过枚举进行遍历\n\n枚举对象：通过枚举函数，生成一个新的对象\n函数用于将一个可遍历的对象，组合为一个索引序列，同时列出数据下标和数据\n\n语法：`enumerate(sequence, [start=0])`\n- sequence：一个序列，迭代器，或者其他支持迭代的对象\n- start：起始位置下标\n\n返回的形式：`[(0, obj0), (1, obj1), ......]`\n\n```python\nfor t in enumerate(l):\n    ......\n```\n也可以使用元组的解包\n```python\nfor idx, obj in enumerate(l):\n    ......\n```\n\n### 通过迭代器进行遍历\n\n#### 简单了解一下迭代器！\n\n什么是迭代：访问可迭代元素的一种方式，也就是可以按照顺序访问每一项\n\n可迭代对象：能够被迭代的对象称为可迭代对象\n判断依据：能作用域for in\n判定方法：\n```python\nimport collections\nisinstance(obj, collections.Iterable)\n```\n\n迭代器：\n- 是可以记录遍历位置的对象\n- 从第一个元素开始，往后通过next()函数进行遍历\n- 只能往后，不能向前\n- 判定依据：能作用于next函数，next(obj)\n- 判定方法：\n  - `import collections`\n  - `isinstance(obj, collections.Iterator)`\n- 注意：迭代器也是可迭代对象，所以也可以作用于for in\n\niter：根据一个可迭代对象返回一个迭代器\n\n#### 为什么会产生迭代器\n\n1. 仅仅在迭代到某个元素时才处理该元素\n  - 在此之前，元素可以不存在\n  - 在此之后，元素可以被销毁\n  - 特别适合用于遍历一些巨大的或者是无限的集合\n2. 提供了一个统一的访问集合的接口\n  - 可以把所有的可迭代对象，转换成迭代器进行使用\n\n#### 迭代器的简单使用\n\n- 使用next()函数，从迭代器中取出下一个对象，从第一个元素开始\n- 因为迭代器比较常用，所以在python中，可以直接作用于 for in\n  - 内部会自动调用迭代器对象，next\n  - 会自动处理迭代完毕的错误\n\n#### 注意\n\n- 如果取出完毕，再继续取，则会报错：`StopIteration`\n- 迭代器一般不能多次迭代\n\n## 判定\n\n列表也是序列类型\n\nin 和 not in，同样可以用于列表\n\n用来判断元素是否存在于列表之中\n\n## 比较\n\n内建函数：cmp()\n\n如果比较的是列表，则针对每个元素，从左到右逐一比较\n- 左 > 右 1\n- 左 == 右 0\n- 左 < 右 -1\n\n在python3中不支持这种方式\n\n---\n\n比较运算符\n\n`==` `<` `>`。。。。。\n针对每个元素，从左到右逐一比较\n\n## 排序\n\n### 内建函数：sort() \n\n可以对所有可迭代对象进行排序\n\n语法：`sorted(iterable, key=None,reverse=False)`\n\n参数：\n- iterable：可迭代对象\n- key：排序关键字，值为一个函数，此函数只有一个参数且返回一个值\n- reverse：控制升序降序，默认False，升序\n\n返回值：一个已经排好序的 `列表`\n\n### 列表方法 list.sort\n\n语法：`list.sort(key=None, reverse=False)`\n\n参数：\n- key：排序关键字，值为一个函数，此函数只有一个参数并且返回一个值用来比较\n- reverse：控制升序降序，默认False，升序\n\n## 乱序\n\n随机打乱一个列表\n\n```python\nimport random\n...\nrandom.shuffle(l)\n```\n\n## 反转\n\n`l.reverse()`\n\n`l[::-1]`', 'title': 'Python：列表类型', 'categories': ['[随笔分类]Python~语法'], 'enclosure': {'length': 0}, 'link': 'https://www.cnblogs.com/wbyixx/p/12219620.html', 'permalink': 'https://www.cnblogs.com/wbyixx/p/12219620.html', 'postid': '12219620', 'source': {}, 'userid': '-2'}